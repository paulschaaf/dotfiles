#!/bin/zsh

_batchFile=./${0##*/}
UNAME=`uname`

unset _dry_run

while [ -n "$*" ]; do
    case $1 in
        --dry-run)
            _dry_run=': '
            ;;
        --)
            echo Unknown option $1
            exit 1
            ;;
        *)
            break
            ;;
    esac
    shift
done

_userCmd=$*

source ~/bin/gwSetEnv

# Separate the directory name
GW_START_DIR=${GW_START_SCRIPT%/*}
[ -d ${GW_START_DIR} ] && cd $GW_START_DIR
echo In `pwd`

GW_START_SCRIPT=./${GW_START_SCRIPT##*/}
_gwProduct_upcase=`echo $GW_PRODUCT | sed 's/.*/\U\0/'`

_icon=/gw-dev/icons/${_gwProduct_upcase}_favicon.ico
iconDir=/usr/share/icons/oxygen/48x48
failIcon=$iconDir/actions/process-stop.png
passIcon=$_icon

javaExec=$JAVA_HOME/bin/java
whichJava="pwd:  `pwd`\njava: `which java`\n\n`java -version 2>&1`"
jvmProcess="'$javaExec .*-Dgw.port=${GW_PORT_DEBUG}'"

[ -n "$_dry_run" ] && set -x

echoVar() {
    typeset -p $* | sed 's/^declare\( -x\)* / /'
    echo
}

setGnuScreenTitle() {
    [ -n "$inScreen" ] && echo -n "\ek${GW_TITLE} ${*}\e\\"
}

log_section() {
    local _color=$1
    local _status=$2
    local _taskDesc=$3

    local _status=" $(date '+%R') - ${_status} "

    # indent, then draw an underline the length of the status message
    printf "  \e[4;38;5;243m%-${#_status}s\n" ' '

    # indent with ul, turn ul off & color on, show status, fill remainder with ul
    printf "  \e[0;1;${_color}m%-s\e[0;4;38;5;243m%*s\n" ${_status} $(($COLUMNS - ${#_status} - 2))

    # turn off bold and show the task description
    printf "\e[0;${_color}m%-${COLUMNS}s\n\e[0m"  ' '$_taskDesc
}

runTask() {
    local task=$1
    local successIcon=$2
    local failIcon=$3

    setGnuScreenTitle ${task}

    log_section 44 'START' $task

    SECONDS=0
    # make sure we source the gwb script instead of just running it
    # if it's a Java cmd, display each option indented on a separate line
    eval ${task/.\/gwb/source ./gwb} | sed '/java / { s/ -/\n   -/g }'

    # keep the exit code for the first command in the chain (i.e. not the sed)
    exitCode=$pipestatus[1]
    elapsedTime=`date -u -d @${SECONDS} +"in %T"`

    if [ $exitCode -eq 0 ]; then
        log_section 42 "DONE $elapsedTime" $task
        if [ $successIcon ]; then
            notify-send -c idea -t 5000 -i $successIcon "Completed '$task'" $whichJava
        fi
    else
        log_section '48;5;196' "FAIL exit($exitCode) $elapsedTime" $task
        if [ $failIcon ]; then
            notify-send -c idea -t 10000 -u critical -i $failIcon "Failed '$task' (exit code $exitCode)" $whichJava
        fi
    fi

    setGnuScreenTitle
}

${_dry_run} konsoleprofile colors=$GW_PRODUCT\;icon=${_icon}\;tabTitle=$GW_TITLE

grepProcStr() {
    echo "pgrep -af $1"
}

killProcStr() {
    echo `grepProcStr $1`" && pkill -f $1"
}

if [ -z $_dry_run ]; then
    for task in `echo $_userCmd`; do
        fullTask="$GW_START_SCRIPT $task"
        taskFailIcon=
        taskPassIcon=
        case $task in
            dropDb*)
                taskFailIcon=$failIcon
                ;;
            killStudio*)
                fullTask=`killProcStr idea`
                taskFailIcon=$failIcon
                ;;
            pgrep*)
                fullTask=`grepProcStr $jvmProcess`
                ;;
            pkill*)
                pgrep -af $jvmProcess
                fullTask=`killProcStr ${jvmProcess}`
                ;;
            fixport*)
                fullTask="ruby -pi -e 'gsub(/:(null|8080)\/cc\//, %q(:$GW_PORT_DEBUG/cc/))' /tmp/*Guidewire*.html && chrome file:///tmp"
                ;;
            studio*)
                taskFailIcon=$failIcon
                ;;
            tasks*)
                taskFailIcon=$failIcon
                ;;
            testFail*)
                fullTask='time && sleep 1 && ls *wojaljg209'
                ;;
            testPass*)
                fullTask='time && sleep 1s'
                ;;
            *)
                taskPassIcon=$passIcon
                taskFailIcon=$failIcon
                ;;
        esac

        # append 'Loud' or 'Quiet' to any task name to override the task default for OS notification
        if [[ ${task} =~ "Quiet$" ]]; then
            taskPassIcon=
            taskFailIcon=
            fullTask=${fullTask%Quiet}
        elif [[ ${task} =~ "Loud$" ]]; then
            taskPassIcon=$passIcon
            taskFailIcon=$failIcon
            fullTask=${fullTask%Loud}
        fi

        runTask ${fullTask} ${taskPassIcon:-''} ${taskFailIcon:-''}
    done
fi

# for CYGWIN
#     _shell=GWSt_${GW_PL}-${_gwProduct_upcase}.lnk
#     echoVar _shell
#     _priority=' /HIGH'
#     if [ ! -e $_shell ]; then
#         echo '# Creating shortcut...'
#         COMSPEC=`cygpath -au $COMSPEC`
#         _desc="${GW_PLATFORM}_${GW_PRODUCT}"
#         _icon=/c${_icon}

#         _mkshortcut="mkshortcut --name=${_shell} --desc=${_desc} --icon=${_icon} --workingdir=$GW_START_DIR ${COMSPEC}"
#     _start='cmd.exe /C start'

#     ${_dry_run}${_start}${_size}${_priority}$_shell ${_terminate:-/K} "${GW_COLOR:+color $GW_COLOR & }title $GW_TITLE & set CMD=${CMD} & %CMD%"
