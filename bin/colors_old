#!/usr/bin/env ruby

# $Source: e:/MyDocuments/cvsroot/src/Makefile,v $
# $Revision: 1.1 $
# $Date: 2003/08/30 00:16:28 $
# $Author: pschaaf $
# $State: Exp $
# $Name:  $

require 'lib/ansicolor.rb'

fieldWidth = 7
indent = ' '
grouping = [:common_effects, :foregrounds, :backgrounds]
error = 0

class Array
  def roll(n=1)
    n.times {|i| self.push(self.shift)}
    self
  end
end

class Object
  def fit(*args)
    self.to_s.fit(*args)
  end
end

class String
  def fit(n)
    self.slice(0..n).ljust(n+1)
  end
end

class ShowUsage < ArgumentError; end

begin
  until ARGV.empty?
    case ARGV[0]

    when /^-a$/
      allSections = true

    when /^-t$/
      ARGV.shift
      displayStr = ARGV.shift || `hostname`.split('.')[0].chomp

    when /^-(u|-uncommon)$/
      grouping[grouping.index(:common_effects)] = :uncommon_effects

    when /^-?[0,1,2]$/
      grouping.roll(ARGV.first.to_i.abs)

    when /^-(h|-help)$/
      raise(ShowUsage, '')

    when /^--$/
      ARGV.shift
      break

    when /^-.*/
      raise(ShowUsage, "#$0 error: unknown switch '#{ARGV[0]}'")

    else
      displayStr = ARGV.to_s || `hostname`.split('.')[0].chomp
      break

    end

    ARGV.shift
  end

  sections, rows, columns = *grouping.collect {|e| Color.send(e)}
  sections += Color.uncommon_effects if allSections

  printf "%ssection = %s, row = %s, column = %s", indent.fit(fieldWidth), *grouping
  puts; puts

  fieldWidth +=4 if rows == Color.backgrounds

  displayStr = displayStr.fit(fieldWidth) if displayStr

  printf indent.fit(fieldWidth)

  # column headers
  columns.each {|column|
    printf "%s%s", column.fit(fieldWidth), indent
  }
  puts

  sections.each {|section|
    section_color = Color.send(section)
    puts '', indent.fit(fieldWidth) + section.to_s.upcase
    rows.each {|row|
      row_color = Color.send(row) + section_color
      printf row.fit(fieldWidth)
      columns.each {|column|
        column_color = Color.send(column)
        cell_color = row_color + column_color
        printf cell_color
        printf displayStr || cell_color.simplify_colors[1..-1].fit(fieldWidth)
        printf Color.clear + indent
      }
      puts
    }
  }

  unless displayStr
    puts %Q<
     Precede each ascii string with an escape left-bracket, like this:

        echo "#{Color.yellow('I\'m solid gold baby, yea\!').bold.on_black.gsub(/\e/, '\\e')}"

     The numbers can appear in any order.>
  end

rescue ShowUsage => ex
  puts ex, '' unless ex.message.empty?

  grouping[grouping.index(:common_effects)] = :effects

  puts <<EOF
#{File.basename($0)} [-h | [-u] [0 | 1 | 2]] [displayString]
Sends tables of ANSI character effects to stdout.

    -a       Show common and uncommon effects.
    -h       Shows this help screen
    -t text  Use 'text' as the display string instead of the default. For an
             empty string, use -t ''.
    -u       Shows uncommon (not as widely supported) effects instead

    -0       grouping = #{grouping.join(",\t")}
    -1       grouping = #{grouping.roll.join(",\t")}
    -2       grouping = #{grouping.roll.join(",\t")}


Grouping:
The items are displayed in a large table. To simulate a third dimension,
rows are grouped by section--it is easiest to think of this as the top
level of organization. Section, row, and column map to one of background
color, text effect, and foreground color. Supply the switch -1 or -2 to
reorder the default mapping.

             Column-1  Column-2  Column-3  ...
      Section-1
    Row-1     xxxxx     xxxxx     xxxxx
    Row-2     xxxxx     xxxxx     xxxxx
    Row-3     xxxxx     xxxxx     xxxxx
    ...

      Section-2
    Row-1     xxxxx     xxxxx     xxxxx
    Row-2     xxxxx     xxxxx     xxxxx
    Row-3     xxxxx     xxxxx     xxxxx
    ...

      Section-3
    Row-1     xxxxx     xxxxx     xxxxx
    Row-2     xxxxx     xxxxx     xxxxx
    Row-3     xxxxx     xxxxx     xxxxx
    ...

    (etc.)

Send bug reports to paul_schaaf@yahoo.com
EOF

  exit(ex.message.empty? ? 0 : 1)

end
