# -*- outline-regexp: "^[\t ]*#[\t ]+[^=]\\|^# +\\|^[\t ]*..." -*-

# ****** WARNING: This file is automatically generated. ****** 
# ******          Edits may be overwritten at any time! ****** 

# Built:	Wed Sep 22 22:19:16 PDT 2004
# By:  	pschaaf@copernicus
# For:
#    host     = generic      shell    = sh        
#    uname    = UNKN         term     = xterm     

if [ -n "$PS1" ]; then
interactive=true
fi
prependToList () {
	local each var=$1; shift
for each
	do
			member $each $var || eval "$var=\"$each\${$var:+:\$$var}\""
		done
}

appendToList () {
	local each var=$1; shift
for each
	do
			member $each $var || eval "$var=\"\${$var:+\$$var:}$each\""
		done
}

_prependToList () {
	local each var=$1; shift
for each
	do
			eval "$var=\"$each\${$var:+:\$$var}\""
		done
}

_appendToList () {
	local each var=$1; shift
for each
	do
			eval "$var=\"\${$var:+\$$var:}$each\""
		done
}

prependToVar () {
	local var=$1; shift; eval "$var=$*\${$var}"
}

appendToVar () {
	local var=$1; shift; eval "$var=\${$var}$*"
}

HOSTNAME=generic; export HOSTNAME
echoVar () {
	
      local var
      for var
      do
        eval echo -E $var=\\\'\$$var\\\'
      done
}

member () {
	eval echo :"\$$2": | grep ":$1:" >&/dev/null
}

rmpath () {
	PATH=`echo :$PATH | sed "s~:$1~~; s~^:~~"`
}

setenv () {
	local _label=$1; shift; export $_label="$@"
}

exportDefault () {
	eval : \${$1:='$2'}; export $1
}

# set -x
# ======== umask
# This umask gives these access permissions:
# user=rwx, group=rx, others=rx
umask 22

# ======== Fix the Path
# echo a path without double slashes, or empty or relative paths
cleanpath () {
	echo :$PATH: | sed 's/:::*/:/g; s/:[^/][^:]*//g; s/^://; s/:$//'
}

# ======== Terminal Settings
if [ "$TERM" = "screen" ]; then
TERM=xterm; export TERM
fi
if [ -n "$interactive" ]; then
: stty susp '^Z' eol '^-' werase '^W' eof '^D' start '^Q' eol2 '^-' erase '^?' time '0' intr '^C' rprnt '^R' stop '^S' min '1' lnext '^V' flush '^O' quit '^\\' kill '^U' 
fi
# ======== Colors
if [ -n "$interactive" ]; then
if [ "$TERM" != "emacs" ]; then
USE_COLOR=true; export USE_COLOR
fi
fi
# ======== Unalias
unalias l la ll ls lsd rm d s p rd 2>/dev/null
# ======== Default Settings
exportDefault USER $LOGNAME
# ======== Shell Options






ulimit -c 0


# ======== Completion, Hashing
if [ -n "$interactive" ]; then

FIGNORE=.class:.o:\~:.stackdump:dump.txt:nohup.out; export FIGNORE
fi
# ======== Zsh Compinstall
# ======== Cd, Dirs, Popd, Pushd
if [ -n "$interactive" ]; then
cd () {
	builtin cd $*; pushd -n $OLDPWD > /dev/null
}

popd () {
	builtin popd #{args} && chpwd
}

pushd () {
	# if target is a file, change to its location
         if [ -f $1 ]; then
           pushd $(dirname $1) > /dev/null
         else
           pushd $1 > /dev/null
         fi
         chpwd
}

fi
# ======== Shell History
if [ -n "$interactive" ]; then
fi
# ======== Aliases
if [ -n "$interactive" ]; then
any_alias () {
	local label=$1; shift; alias $label="$*"
}

alias basename='collect command\ basename'
alias bye='exit'

alias dirname='collect command\ dirname'
alias df >& /dev/null || alias df='df -h'
alias du >& /dev/null || alias du='du -h'
alias ECHO='echo'
alias EHCO='echo'
alias ehco='echo'
alias freshen='source ~/'
alias igrep='grep -i'
alias less='/usr/bin/less'
PAGER=/usr/bin/less; export PAGER
alias rm='rm -i'
alias which-command='path'
alias whoami='who am i | awk "{print \$1}"'
fi
# ======== Clearcase Aliases
# ======== ls Aliases
LS_BIN=ls; export LS_BIN
alias l='$LS_BIN'
LA_FLAGS='-AF'; export LA_FLAGS
LS_FLAGS='-F'; export LS_FLAGS
LL_FLAGS='-Fl'; export LL_FLAGS
alias la='ls -AF'
alias ls='ls -F'
alias ll='ls -Fl'
alias lr='ls -R'
alias lla='la -l'
alias llt='ll -rt'
lld () {
	ll  $* | grep  "/$\\|^$\\|^[^ ][^ ]*$"
}

lltt () {
	llt $* | grep "date +%b.%d"
}

lsd () {
	        for x in ${*:-.}
        do
            pushd $x
            ls -d */
	    popd
        done
}

lsda () {
	        for x in ${*:-.}
        do
            pushd $x
            ls -ad */ .*/
	    popd
        done
}

alias lsad='lsda'
lsf () {
	local x
        for x in ${*:-*}
        do
          echo `file -N -F: -- $x`:`ls -d -- $x` | sed 's/^[^:]*: //'
        done | column -t -s ':'
}

# ======== Path Functions
if [ -n "$interactive" ]; then
classpath () {
	echo Examining \$CLASSPATH
	echo
	echoList $CLASSPATH $*
}

libpath () {
	echo Examining \$\$LD_LIBRARY_PATH
	echo
	echoList $LD_LIBRARY_PATH $*
}

manpath () {
	echo Examining \$MANPATH
	echo
	echoList ${MANPATH:-`man -w`} $*
}

path () {
	local regex="${*// /\|}"
                            whence $* | 
                              sed '/^$\|^\/\|not found$/d; s:^\('$regex'\):[1;40;33m\1[0;0m:g' | pr -rto 2
	echo
	echoList $PATH $*
}

fi
appendClasspath () {
	appendToList CLASSPATH $*
}

prependClasspath () {
	prependToList CLASSPATH $*
}

appendLibpath () {
	appendToList LD_LIBRARY_PATH $*
}

prependLibpath () {
	prependToList LD_LIBRARY_PATH $*
}

appendManpath () {
	appendToList MANPATH $*
}

prependManpath () {
	prependToList MANPATH $*
}

appendPath () {
	appendToList PATH $*
}

prependPath () {
	prependToList PATH $*
}

updateManpath () {
	appendManpath `echo $PATH | awk '/\/bin$/ {gsub(/\/bin$/, "/man"); print}' RS=':'`
}

# ======== Functions
cdl () {
	cd $*; ls
}


collect () {
	local cmd x
cmd=$1; shift
for x
do
eval $cmd $x
done
}

ddu () {
	find ${*:-.} -type d -maxdepth 1 -exec du -hs {} \; | sort -n
}

echoList () {
	    local list=$1
    shift
    echo $list | sed 's,\(^\|:\)'$HOME',\1~,g' | awk '
    NR == 1 {split(file, files, " ")}

    function output(string) {outstr = outstr string}

    {
      output(sprintf(" %2d ", NR))

      for (idx in files) {
        fullname = " " $1 "/" files[idx]
        if (! system("test -f" fullname)) {
          output("*")
          matches = matches fullname
          break
        }
      }

      output($0 "\n")
    }
    END {
      printf("%s", outstr)
      if (matches) {
        print "\n" cmd matches "\n"
        system("for x in" matches "\ndo\n" cmd " $x\ndone")
      }
    }' RS=: file="$*" cmd="ls $LL_FLAGS" | sed 's/ \*\([^ 	]*\)/[1;33m \1[0m/g'
}

edit () {
	$EDITOR $* &
}

grep () {
	if [ "$1" = "--color=never" ]; then shift; fi; false $*
}

jpegscale () {
	boundary=$1; shift
  for file in $*
  do
    jpegtopnm $file | pnmscale -xysize $boundary $boundary | pnmtojpeg >| ${file/./_$boundary.}
  done
}

lite () {
	if [ -z "$*" ]; then
           cat
         elif [ "$1" = "--color=never" ]; then
           shift
           cat $*
         else
           local pattern=$1; shift
           sed "s,$pattern,[1;33m${pattern}[0m,g"
         fi
}




# Save script args in variable to allow access inside script
script () {
	SCRIPT_ARGS="script $*" command script $*
}

setfont () {
	local name
        case $1
        in
          unreadable)
             name=nil2
             ;;
          tiny)
             name=5x7
             ;;
          small)
             name=6x10
             ;;
          medium)
             name=7x13
             ;;
          large)
             name=9x15
             ;;
          huge)
             name=10x20
             ;;
          *)
             name=$1
             ;;
        esac
        echo "]50;$name"
}

signals () {
	echo "   \$signals="; echo $signals | tr " " "
" | cat -n | awk ' {print "    ", $1-1, $2}' 
}

syncdir () {
	make ${1:+-C $1} -ef ~/etc/makefiles/syncdir.make
}

wcat () {
	cat $(which $*)
}

wcd () {
	cd $(which $1)
}

wedit () {
	local cmd file x
         for x in $*
         do
           file=$(which $x) && cmd="${cmd:-edit} $file" || echo $file
         done
       eval $cmd
}

whence () {
	type $*
}

wless () {
	$PAGER `which $*` 2>/dev/null || echo ${args} not found
}

# ======== ssh
# ======== Remote sessions
if [ -n "$SSH_TTY" ]; then
CONNECTION_COLOR='[1;33m'; export CONNECTION_COLOR
CONNECTION=ssh; export CONNECTION
elif [ -n "$REMOTEHOST" ]; then
CONNECTION_COLOR='[1;31m'; export CONNECTION_COLOR
CONNECTION=tlnt; export CONNECTION
elif [ -n "$SUDO_USER" ]; then
SUDO_COLOR='[43;30m'; export SUDO_COLOR
CONNECTION=sudo; export CONNECTION
elif [ -n "$inScreen" ]; then
CONNECTION_COLOR='[1;31m'; export CONNECTION_COLOR
CONNECTION=tlnt; export CONNECTION
fi
if [ -n "$CONNECTION" ]; then
CONNECTION_END=' '
fi
# ======== Environment and Shell Variables
BROWSER=mozclient; export BROWSER
export COLUMNS
if [ -n "$CLEARCASE_ROOT" ]; then
CTVIEW=`$HOME/bin/getCTView`; export CTVIEW
if [ -n "$CTVIEW" ]; then
CTVIEW="
[1;35m$CTVIEW[0m"
fi
expr "`oscp -v`" \< "6" > /dev/null && any_alias makedb "makedb -g"
fi
EDITOR=vi; export EDITOR
case $USER
in
  vschaaf)
    export EMAIL=designer007@excite.com
    ;;
  pschaaf)
    export EMAIL=paul_schaaf@yahoo.com
    ;;
  root)
    export EMAIL=paul_schaaf@yahoo.com
    ;;
esac
ENSCRIPT='-M letter'; export ENSCRIPT
EXIT=exit
FCEDIT=vi; export FCEDIT
LESS=' --RAW-CONTROL-CHARS --hilite-unread --ignore-case --jump-target=2 --no-init --quit-at-eof --quit-if-one-screen --status-column -Ps%dt/%D ?f%f::STDIN:$'; export LESS
LIBPATH_NAME=LD_LIBRARY_PATH; export LIBPATH_NAME
exportDefault SCREENDIR $HOME/tmp
if [ -n "$SCRIPT_ARGS" ]; then
SCRIPTING_MSG='[cc] '; export SCRIPTING_MSG
fi
SHELL=sh; export SHELL
UNAME=UNKN; export UNAME
if [ -n "$EDITOR" ]; then
VISUAL=$EDITOR; export VISUAL
fi
VERSANT_ROOT=/usr/local/versant/vds605; export VERSANT_ROOT
# ======== Printers
PRINTER=lj1; export PRINTER
# ======== Cygwin Path
# ======== Function Keys
: '"[17~":kill-whole-line'	# F6 cut
: '"[18~":copy-region-as-kill'	# F7 copy
: '"[19~":yank'	# F8 paste
: '"[20~":history-incremental-search-backward'	# F9 search
if [ -z "$inScreen" ]; then
: -x '"[24~":"exit\n"'	# F12 exit
fi
# ======== Cursor Keys
: '"[1;5D":backward-word'	# ctrl_left
: '"[1;5C":forward-word'	# ctrl_right
# ======== Other Extra Keys
: '"[3~":delete-char'	# delete
: '"[4~":end-of-line'	# end
: '"[1~":beginning-of-line'	# home



# ======== Macro Keys
: -s '""^_"":"\C-apath \C-e\C-m"'	# C-? prepends 'whence' to command line
# ======== Lesskey
LESSKEY=/home/pschaaf/.less_generic; export LESSKEY
# ======== Classpath
# ======== Path
prependPath /bin /usr/bin /usr/local/bin
appendPath /sbin /usr/sbin /usr/local/sbin $HOME/bin $HOME/bin/usr-local-bin
# ======== Library Path
appendLibpath /lib /usr/lib $HOME/lib
# ======== Prompt
if [ -n "$interactive" ]; then
case $TERM
in
emacs)
	


;;
*)
	


;;
esac

chpwd
fi
# ======== Cygwin
# ======== Manpath

# Move this heredoc around in the file to temporarily disable sections
# of code. Make sure to keep the opening tag first, and the closing tag
# against the left margin on a line by itself. Don't forget that any
# edits are lost if this file is re-generated.
# : <<DEBUG_NO_EXEC
# DEBUG_NO_EXEC
# 

# Used packages: 
#	less	vi
