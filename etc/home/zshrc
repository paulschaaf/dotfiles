#@IgnoreInspection BashAddShebang
# -*- mode: shell-script; compile-command: (concat "zcompile '" buffer-file-name "'"); outline-regexp: "^[\t ]*#[\t ]+[^=]\\|^# +\\|^[\t ]*..." -*-

# This script is run by interactive shells

# 1) All:         /etc/zshenv,       $ZDOTDIR/.zshenv
# 2) Login:       /etc/zprofile,     $ZDOTDIR/.zprofile
# 3) Interactive: /etc/zshrc,        $ZDOTDIR/.zshrc
# 4) Login:       /etc/zlogin,       $ZDOTDIR/.zlogin
# ...
# 5) Login:       $ZDOTDIR/.zlogout, /etc/zlogout

log=:
#log=echo
$log '*** In .zshrc'
#set -x

# ======== Exported Variables
export EDITOR=/usr/bin/emacs
ifMacOS && EDITOR=/usr/local/bin/emacs
ifRoot && EDITOR=${EDITOR}' -u pschaaf -nw'

export ESHELL=$SHELL
export FCEDIT=zed
export FIGNORE=.class:.o:\~:.stackdump:dump.txt:nohup.out
if (( ! EUID )); then
  HISTFILE=~/.history_root
else
  HISTFILE=~/.history
fi
export HISTSIZE=1000
export SAVEHIST=1000
export LESS=' --RAW-CONTROL-CHARS --hilite-unread --ignore-case --jump-target=2 --no-init --quit-if-one-screen --status-column -Ps%dt/%D ?f%f::STDIN:$'
export LESSKEY=${HOME}/.less_$HOSTNAME
export NVM_DIR=$HOME/.nvm
export PAGER=less
export MANPAGER=less
export RIPGREP_CONFIG_PATH=~/etc/rc/ripgreprc
export USE_COLOR=true

# Any punctuation char in WORDCHARS is considered a part of the adjacent word.
# The remaining punctuation chars are considered separate words, regardless of
# what may be adjacent:  !"#&'()+,./:;<=>?@[]`{|}
export WORDCHARS='|*?-~\\$%^'


# ======== Aliases
alias ..='pushd ..'
alias ...="pushd ../.."
alias cd=pushd
alias cores='inxi -C'
alias du='du -h'
[[ $USER != pschaaf ]] && alias emacs='emacs -u pschaaf'
ifMacOS && alias home="printf '\e[3;0;0;1t\e[8;142;100t'" # move to upper left then resize terminal -- see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html
ifCygwin && alias open=explorer
ifLinux && alias open=dolphin
alias pd=popd
alias rm='rm -i'
alias root='sudo -u root ZDOTDIR=~pschaaf zsh -il'
alias term='echoVar TERM'
alias tree="tree -a --dirsfirst"
alias vpnc-connect='sudo vpnc-connect'
alias vpnc-disconnect='sudo vpnc-disconnect'
ifMacOS && alias work="printf '\e[3;0;0;1t\e[8;106;100t'"


# ======== ls Aliases and Functions
export LS_COLORS='no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;37;41:mi=01;37;41:ex=01;32:*.btm=01;32:*.tar=01;31:*.tgz=01;31:*.tbz2=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lha=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:*.tiff=01;35'
export LS_FLAGS=-BCFbh
$ifZsh export LS_FLAGS=${LS_FLAGS}H
unalias l la ll ls lsd lld lsda lldarm d s p rd 2>/dev/null
alias l=/bin/ls
ifMacOS \
    && LS_FLAGS="${LS_FLAGS}G" \
    || LS_FLAGS="${LS_FLAGS}${LS_COLORS:+ --color}"

export LS="l ${LS_FLAGS}"
alias ls=${LS}

alias la='ls -A'
alias ll='ls -l'
alias lla='ls -Al'

alias llt='ls -lrt'
alias lr='ls -R'
lsd() {
    dir=${1}${1:+/}
    l ${LS_FLAGS/F/} -d ${dir}*/
}
lld() {
    dir=${1:-.}
    ls -ld ${dir}/*/
}
lsda() {
    if [[ $# -eq 0 ]]; then
	    l ${LS_FLAGS/F/} -ld */(D)
    else
        for dir in ${*}; do
            echo
            ls -d $dir
            l ${LS_FLAGS/F/} -ld ${dir}/*/(D)
        done
    fi
}

alias llda='lsda -l'

lsf() {
    local x
    for x in ${*:-*}; do
        echo `file -N -- $x`:`ls -d -- $x` | sed 's/^[^:]*: //'
    done | column -t -s ':'
}


# ======== Var and List Processing

echoList() {
    local listName=$1; shift
    eval local contents=\$${listName}

    local ifDebug=:
    local show_type=''
    local rm_row=
    local RS=${RS:-:}

    while [[ -n "$*" ]]; do
        case $1 in
            --debug)
                ifDebug=
                shift
                ;;
            --help)
                echo '--help       Show this screen'
                echo '--show-type  Shows the type of the argument files'
                echo '--rm \#      Removes item number # from the list and print the new value'
                return
                ;;
            --rm)
                shift
                rm_row=$1
                shift
               ;;
            --show-type)
                show_type='file -L'
                shift
                ;;
           --*)
                echo Unrecognized option "$1"!
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    $ifDebug echo '=====' "listName=$listName"
    $ifDebug echo '=====' "contents=$contents"

    $ifZsh echo " ${listName} has type ${(Pt)listName}"

    # let us know if it's also a function or alias
    local override=`type $1`
    override=${override//$1 is \/*/} # it's neither
    override=${override//not found/is not an alias, function or executable}

    echo -E ${contents} | awk '
    NR == 1 {split(file, files, " ")}
    {
      gsub("/c" ENVIRON["HOME"],"~")
      gsub(ENVIRON["HOME"],"~")
      dirname = $0
      carat = " "
      startColor = ""
      endColor = "[0m"
      for (idx in files) {  # note if any of the argument files are in this dir
        fullpath = $1 "/" files[idx]
        if (! system("test -f " fullpath)) {
            startColor = "[1;33m"
            matches = matches " " fullpath
            carat=">"
            break
        }
      }
      if (NR == rm_row) {
          startColor = sprintf("%s", "[101m")
      }
      printf("\n%s%2d %s%s%s", carat, NR, startColor, dirname, endColor)
    }
    END {
        if (override) {
            print "\n" override
        }
        if (matches) {
            print "\n" ls matches
            system(ls matches)
            if (show_type) {
                print "\n" show_type matches "\n"
                system(show_type matches)
            }
        }
    }' RS=${RS} file="${*}" ls="/bin/ls \${LS_FLAGS} -Hl" override=$override rm_row="${rm_row:-999}" show_type=${show_type}

    if [[ -n $rm_row ]]; then
        contents=`echo ${contents} | awk 'NR != RM_ROW {print}' RM_ROW=$rm_row RS=${RS} ORS=${RS}`
        eval $listName=$contents # update the var
        echo "\n"Removed row $rm_row from $listName
        $ifDebug echo '=====' "listName=$listName"
        $ifDebug echo '=====' "contents=$contents"
    fi

    [[ $# -lt 2 ]] && return

    shift
    echo "\nIgnored extra arguments: '$*'!"
    return 1
}

echoVar() {
    local var
    for var; do
        echo -n "\n # ${var} has type ${(Pt)var}\n "
        typeset -p ${var} | sed 's/^typeset -x//'
    done
}

alias classpath='echoList CLASSPATH'
alias grep='command grep --extended-regexp --color'
alias fpath='echoList FPATH'
alias libpath='echoList LD_LIBRARY_PATH'
alias path='echoList PATH'

rubylib() {
    echoVar RUBYLIB
    echo
    local RUBYLIB=`ruby -e 'print $:.join(":")'`
    echoList RUBYLIB | sed -e 's/^  *RUBYLIB .*/ Including implicit dirs:/'
}


# ======== Zsh Compinstall

if  [[ -z "$ifZsh" ]]; then
    zstyle ':completion:*' expand prefix suffix
    zstyle ':completion:*' file-sort name
    zstyle ':completion:*' group-name ''
    zstyle ':completion:*' ignore-parents parent ..
    zstyle ':completion:*' list-colors ''
    zstyle ':completion:*' list-prompt '%SAt %p: Hit TAB for more, or the character to insert%s'
    zstyle ':completion:*' menu select=0
    zstyle ':completion:*' select-prompt '%SScrolling active: current selection at %p%s'
    zstyle ':completion:*' squeeze-slashes true
    zstyle ':zftp:' titlebar true
    zstyle ':completion:*' verbose true
    zstyle  :compinstall filename "$HOME/etc/rc/$HOST.zsh"

    fpath=(~/etc/zshcompletion $fpath)

    autoload -U compinit && compinit
    autoload zed                  && alias fned='zed -f'
    unalias  run-help 2>/dev/null && autoload run-help
    zmodload -i zsh/complist
#    autoload -U compinit
    compinit
fi


# ======== Shell Options

if  [[ -z "$ifZsh" ]]; then
    unsetopt \
        beep \
        clobber \
        flow_control \
        hup \
        notify \
        print_exit_value \
        rm_star_silent

    setopt \
        auto_list \
        auto_menu \
        auto_param_slash \
        auto_pushd \
        auto_remove_slash \
        bang_hist \
        correct \
        extended_history \
        function_argzero \
        hash_cmds \
        hash_dirs \
        hist_find_no_dups \
        hist_ignore_dups \
        hist_ignore_space \
        hist_no_functions \
        hist_reduce_blanks \
        ignore_eof \
        inc_append_history \
        pushd_silent \
        share_history
fi


# ======== Functions and Aliases

alert() {
  if [[ $? -eq 0 ]]; then
    notify-send -t 3000 -i info Success\! "\n$1"
  else
    notify-send -t 5000 -i error Failed\! "\n$1"
    return 1
  fi
}

df() {
    /bin/df -hl -x devtmpfs -x tmpfs --total -T $* | lite -c cyan '^total.*' -c underline '^Filesystem.*'
}
ifMacOS && function df() { /bin/df -Phl $* }

ddu() {
    # show the size of each subdirectory
    find ${*:-.} -maxdepth 1 -type d -print0 | xargs -0 du -hs | sort -n
}

#function @#() {
#    printf "\e[48;5;21m\n--- $*\e[0m\n"
#}

# basename() { echo ${(F)@:t} }
# dirname() { echo ${(F)@:h} }

ifMacOS && find() { [[ $1 == -* ]] && command find . $* || command find $* }

frotz() {
    pushd ~/Box\ Sync/Infocom
    local stories=".*/${1:-.*}\\.dat\$"
    if [[ "$*" = "" ]]; then
        # if no args, show all game files
        find . -regex $stories -print | sed 's/^\.\//  /; s/\.dat$//' | sort
    else
        # otherwise run the one requested
        local story=`find . -maxdepth 1 -regex $stories -print -quit`
        story=${story#./}
        echo Story is $story
        if [[ -f ${story} ]]; then
            dir=${story%%.*}
            mkdir $dir
            builtin cd $dir
            command frotz ../$story
            builtin cd ..
            rmdir $dir 2>/dev/null // remove only if empty
        else
            echo Cannot find story "$story"
        fi
    fi
    popd
}

if [[ -n $inIntelliJ ]]; then
    rg() {
        command rg --no-heading --column ${*:-.} | sed -E "
# prepend PWD to all relative paths
s_^([^/])_${PWD}/\\1_;

# remove unnecessary relative paths
s_/\\./_/_;

# if in gw-studio, prepend file:// to each absolute path so it appears as a link
s_^/_${GW_PRODUCT:+file://}/_
"
    }
fi

pcd() {
    # Change to the specified dir & remove starting place from dir stack
    cd "$@"; popd +1 2>/dev/null
}

# cd to the specified directory, or if it's a file, to the containing directory
pushd() {
    if [[ -z "$1" ]]; then
        builtin pushd
    elif [[ -f "$1" ]]; then
        builtin pushd ${1:h}
    else
        builtin pushd ${1}
    fi
}

settitle() { printf '\e]1;%s\a' ${*:-$GIT_REPO} }

splitMp3() {
   local file=$1
   local base=${1%%.*}
   local extension=${1##*.}
   local title=${2:-$base}
   local index=1
   set -x
   ffmpeg -i ${file} -f segment -segment_time 600 -c copy tmp_${base}%03d.${extension}

   count=`ls -1q tmp_* | awk 'END {print NR}'`
   for track in tmp_*; do
      ffmpeg -i ${track} -metadata title="${title} ${index}/${count}" -c copy ${track##tmp_}
      rm -f ${track}
      : $((index++))
   done
}

splitFlac() {
    local cue=$1
    local flac=$2
    if [[ "${2##*.}" = "cue" ]]; then
        cue=$2
        flac=$1
    fi
    echo "    CUE  = $cue"
    echo "    FLAC = $flac"
    shnsplit -f $cue -t %n-%t -o flac $flac
}

wcat() { cat $(which $*) }
wcd() { cd $(which $*) }
wfile()  { file $(which ${@}) 2>/dev/null || echo \'${@}\' not found }
whence() { builtin whence -ac $* }
wless()  { ${PAGER} $(which ${@}) 2>/dev/null || echo \'${@}\' not found }
wedit() {
    local cmd file x
    for x in $*
    do
        file=$(which $x) && cmd="${cmd:-edit} $file" || echo $file
    done
    eval $cmd
}



# ======== Key Bindings

# Use Emacs key bindings
bindkey -e

bindkey -s "[Z" " popd\n"

# Here's what we'd like to accomplish:
#    __PRESS__  __TO__
#    F6         cut
#    F7         copy
#    F8         paste
#    F9         search
#    F12        exit

bindkey "[17~" kill-whole-line
bindkey "[18~" copy-region-as-kill
bindkey "[19~" yank
bindkey "[20~" history-incremental-search-backward
bindkey -s "[21~" " exit\n"

# ======== Other Extra Keys

# Here's what we'd like to accomplish:

#   __PRESS __  __TO__
#   ctrl_left   backward-word
#   ctrl_right  forward-word

#   home        beginning-of-line
#   end         end-of-line

#   ctrl_delete backward-kill-word
#   delete      delete-char

bindkey "\033[3~" delete-char

# echo; (bindkey | grep 'backward-delete-char'; echo; bindkey | grep 'backward-kill-word') | sed 's/" /"\t/g'

bindkey "\M-C\M-5" up-case-word
bindkey "\M-C\M-," down-case-word

case ${TERM} in
    cygwin*)
        bindkey "\033H"     backward-delete-char
        bindkey "\033?"     backward-kill-word
        bindkey "\033[1;5D" backward-word
        bindkey "\033[1~"   beginning-of-line
        bindkey "\033[4~"   end-of-line
        bindkey "\033[1;5C" forward-word
        bindkey "\033[3;5~" kill-word
        ;;
    rxvt*)
        bindkey "^H"        backward-delete-char
        bindkey "\033Od"    backward-word
        bindkey "\033[7~"   beginning-of-line
        bindkey "\033[3~"   delete-char-or-list
        bindkey "\033[8~"   end-of-line
        bindkey "\033Oc"    forward-word
        bindkey "\033[3;5~" kill-word

        bindkey "\033?"     backward-kill-word
        bindkey "\033[1;5D" backward-word
        bindkey "\033[1~"   beginning-of-line
        bindkey "\033[4~"   end-of-line
        bindkey "\033[1;5C" forward-word
        bindkey "\033[3;5~" kill-word
        ;;
    xterm*)
        bindkey "^?"        backward-delete-char
        bindkey "^H"        backward-kill-word
        bindkey "\033[1;5D" backward-word
        bindkey "\033[H"    beginning-of-line
        bindkey "\033[1~"   beginning-of-line
        bindkey "\033[3~"   delete-char-or-list
        bindkey "\033[4~"   end-of-line
        bindkey "\033[F"    end-of-line
        bindkey "\033[1;5C" forward-word
        bindkey "\033[3;5~" kill-word
        ;;
    *)
        echo Unknown terminal type: $TERM
        ;;
esac

# ======== Macro Keys
# C-? prepends 'whence' to command line
bindkey -s ""^_"" "\C-apath \C-e\C-m"
#     if [[ -z "$CONNECTION" ]]; then
#         #bindkey -r "\C-h" 	# remove binding
#         #bindkey "\C-h\C-k" describe`-key-briefly	#
#     fi


# ======== Remote sessions
if [[ -n "$SSH_TTY"    ]]; then
    export CONNECTION=ssh
elif [[ -n "$REMOTEHOST" ]]; then
    export CONNECTION=tlnt
elif [[ -n "$SUDO_USER"  ]]; then
    export CONNECTION=sudo
elif [[ -n "$REMOTEUSER" ]]; then
    export CONNECTION=tlnt
fi


# ======== The Prompt

export GIT_PS1_SHOWDIRTYSTATE=1

rootColorString='[37;1;41m'

case $HOSTNAME:$UNAME in
    *:CYGWIN*)
        # white on green
        hostColor='[37;42m'
        ;;
    *:Darwin*)
        hostColor='[32;40m'
        ;;
    *:Linux*)
        # green
        hostColor='[32;40m'
        ;;
    *:Windows*)
        # white bold on blue
        hostColor='[37;1;44m'
        ;;
    *:UNKN*|*)
        # magenta
        hostColor='[35;40m'
        ;;
esac

case $CONNECTION in
    ssh)
        connection_color='[0;30;48;5;226m'
        ;;
    tlnt)
        connection_color='[31;1m'
        ;;
    sudo)
        connection_color='[35;1;40m'
        ;;
    *)
        ;;
esac
if [[ -n "$CONNECTION" ]]; then
    hostColor=${hostColor/m/;4m}  # underline the host name
fi

if [[ -n "$connection_color" ]]; then
    CONNECTION="%{$connection_color%}$CONNECTION%{[0m%} "
fi

if [[ -f ~/etc/rc/git_zshrc.sh ]]; then
    source ~/etc/rc/git_zshrc.sh
else
    function updateGitVars() { : }
    GIT_STATUS=''
fi

export dirs

updateDirs() {
    dirs="`builtin dirs -p | awk '
       NR == 2 {printf(\"%s\", \"[0;38;5;243m\")};
       {print}
    ' ORS=' '`"
}

alias fixprompt='updateGitVars'

function git() {
    command git $*
    echo "$*" | grep --quiet 'checkout\|--edit-description' && updateGitVars
}

autoload -U add-zsh-hook
add-zsh-hook chpwd updateDirs
add-zsh-hook precmd updateGitVars

if [[ -n "$HOSTMESSAGE" ]]; then
    HOSTMESSAGE=" [35;40m$HOSTMESSAGE"
fi

currentUser=${USER//pschaaf/}
currentUser=${currentUser}${currentUser:+@}

PS1="%{[4;38;5;235m%}\${(l.\${COLUMNS}.. .)}
%{$reset_color%}%T %{%(!.%{$rootColorString%}.%{$hostColor%})%}${currentUser}%m%{$reset_color%}$HOSTMESSAGE %{$fg_bold[yellow]%}%62>\>>\$dirs%<<
%{$reset_color%}\$GIT_STATUS%2(L.%{$fg_bold[cyan]%}%L/.)%{$fg_no_bold[cyan]%}%!%{$reset_color%} $CONNECTION$SCRIPTING_MSG\$GW_PROMPT%(!.#.$) "

PS2="(%{[35;1m%}%_%{$reset_color%}) %(!.#.$) "

pcd .


# ======== Guidewire
alias granite='source ~/src/guidewire/granite.env'

# Bootstrap the huge nvm (Node version manager) function
alias nvm='echo Installing...; [[ -s "$NVM_DIR/nvm.sh" ]] && source "$NVM_DIR/nvm.sh" && unalias nvm && nvm || echo ...failed!'


### START-Keychain ###
# Let  re-use ssh-agent and/or gpg-agent between logins
# /usr/bin/keychain $HOME/.ssh/id_rsa $HOME/.ssh/id_dsa
# source $HOME/.keychain/$HOSTNAME-sh
#if [[ $UID -gt 0 ]]; then  # if I'm not root
#    eval `keychain --eval --agents ssh ~/.ssh/id_rsa`
#fi
### End-Keychain ###

# Move this heredoc around in the file to temporarily disable sections
# of code. Make sure to keep the opening tag first, and the closing tag
# against the left margin on a line by itself. Don't forget that any
# edits are lost if this file is re-generated.
: <<DEBUG_NO_EXEC
DEBUG_NO_EXEC
set +x
