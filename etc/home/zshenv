#@IgnoreInspection BashAddShebang
# -*- mode: shell-script; compile-command: (concat "zcompile '" buffer-file-name "'") -*-
# ; outline-regexp: "^[\t ]*#[\t ]+[^=]\\|^# +\\|^[\t ]*..."

# This script is run first by every type of zsh, login, interactive, both, or neither

# 1) All:         /etc/zshenv,       $ZDOTDIR/.zshenv
#    (All invocations unless the -f option is set.) Should contain commands to set the PATH and other important
#    environment variables, but not those that produce output or assume the shell is attached to a tty.

# 2) Login:       /etc/zprofile,     $ZDOTDIR/.zprofile
#    Meant as an alternative to `.zlogin' for ksh fans; though possible the two are not intended to be used together

# 3) Interactive: /etc/zshrc,        $ZDOTDIR/.zshrc
#    Should contain commands to set up aliases, functions, options, key bindings, etc.

# 4) Login:       /etc/zlogin,       $ZDOTDIR/.zlogin
#    Should be used to set the terminal type and run a series of external commands (fortune, msgs, etc). Not the place
#    for alias definitions, options, env vars, etc.: it should not change the shell environment at all.

# ...
# 5) Login:       $ZDOTDIR/.zlogout, /etc/zlogout
#    Sourced when login shells exit.

log=:
$log '*** In .zshenv'

umask 22

# ======== Default Settings
export UNAME=${UNAME:=`uname`}

export ifZsh=:
if [[ "$0" =~ "zsh" ]]; then
    $log zsh!
    ifZsh=
fi

alias ifCygwin=false
alias ifMacOS=false
alias ifLinux=false
case "${UNAME:=`uname`}" in
    CYGWIN)
        alias ifCygwin=true
    ;;
    Darwin)
        alias ifMacOS=true
    ;;
    Linux)
        alias ifLinux=true
    ;;
    *)
    ;;
esac

alias ifRoot=false
if [[ $UID -eq 0 ]]; then
    alias ifRoot=true
fi
alias ifNotRoot='! ifRoot'

# ======== Global Flags
typeset -U CDPATH CLASSPATH FPATH LD_LIBRARY_PATH PATH


# ======== List Functions

appendToVar() {
    local var=$1; shift; eval "$var=\${$var}$*"
}
prependToVar() {
	local var=$1; shift; eval "$var=$*\${$var}"
}

member() {
    eval local value=:\$$2:
    echo $value | grep ":$1:" >& /dev/null
}

prependToList() {
    local each var=$1; shift
    for each; do
        member $each $var || eval "$var=\"$each\${$var:+${RS:-:}\$$var}\""
    done
}

appendToList() {
    local each var=$1; shift
    for each; do
        member $each $var || eval "$var=\"\${$var:+\$$var${RS:-:}}$each\""
    done
}

appendClasspath() {
    appendToList  CLASSPATH $*
}
prependClasspath() {
    prependToList CLASSPATH $*
}

appendLibpath() {
	appendToList  LD_LIBRARY_PATH $*
}
prependLibpath() {
	prependToList LD_LIBRARY_PATH $*
}

appendPath() {
	appendToList  PATH $*
}
prependPath() {
	prependToList PATH $*
}

appendRubyLib() {
	appendToList  RUBYLIB $*
}
prependRubyLib() {
	prependToList RUBYLIB $*
}

cleanList() {
    local listName=$1; shift
    eval local contents=\$$listName
	# remove empty elements and double slashes, escape any spaces
	eval $listName=`echo $contents | sed -E 's_::+_:_g; s_//+_/_g; s_ _\\\\ _g; s_^:__; s_:$__'`
   #   's_:([a-z]):/_:/\1/_g;   ' \   # change windows leading drive letter into *nix path
}


# ======== Path
prependPath $HOME/bin
appendPath ~/bin/quick-ssh /usr/X11R6/bin /opt/git-gw ~/Android/Sdk/platform-tools

export CLASSPATH=${CLASSPATH:=.}


# ======== Remote sessions
if [[ -n "$SSH_TTY"    ]]; then
    export CONNECTION=ssh
elif [[ -n "$REMOTEHOST" ]]; then
    export CONNECTION=tlnt
elif [[ -n "$SUDO_USER"  ]]; then
    export CONNECTION=sudo
elif [[ -n "$REMOTEUSER" ]]; then
    export CONNECTION=tlnt
fi


# ======== Exported Variables
export EDITOR=/usr/bin/emacs
ifMacOS && EDITOR=/usr/local/bin/emacs
ifRoot && EDITOR=${EDITOR}' -u pschaaf -nw'

export EMAIL=paul.schaaf@gmail.com
export ESHELL=$SHELL
export FCEDIT=zed
export FIGNORE=.class:.o:\~:.stackdump:dump.txt:nohup.out
export GIT_PS1_SHOWDIRTYSTATE=1
if (( ! EUID )); then
  HISTFILE=~/.history_root
else
  HISTFILE=~/.history
fi
export HISTSIZE=1000
[[ "${TERMINAL_EMULATOR}" = "JetBrains-JediTerm" ]] && export inIntelliJ=true
export LC_ALL=en_US.UTF-8
export SAVEHIST=1000
ifLinux && export IDEA_ROOT=/opt
export LESS=' --RAW-CONTROL-CHARS --hilite-unread --ignore-case --jump-target=2 --no-init --quit-if-one-screen --status-column -Ps%dt/%D ?f%f::STDIN:$'
export LESSKEY=${HOME}/.less_$HOSTNAME
#export LIBPATH_NAME=LD_LIBRARY_PATH
appendLibpath /lib /usr/lib $HOME/lib
export LS_COLORS='no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;37;41:mi=01;37;41:ex=01;32:*.btm=01;32:*.tar=01;31:*.tgz=01;31:*.tbz2=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lha=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:*.tiff=01;35'
export LS_FLAGS=-BCFbh
$ifZsh export LS_FLAGS=${LS_FLAGS}H
export P4_HOME=/opt/p4v
export P4CLIENT=pschaaf_satori_1124
export PAGER=less
export RUBYLIB
appendRubyLib /home/pschaaf/src/ruby /home/pschaaf/bin
export MANPAGER=less
export RIPGREP_CONFIG_PATH=~/etc/rc/ripgreprc
export SCREENDIR=${SCREENDIR:=${HOME}/tmp}
export SHELL=/usr/bin/zsh
export TERM=xterm-256color
export USE_COLOR=true

# Any punctuation char in WORDCHARS is considered a part of the adjacent word.
# The remaining punctuation chars are considered separate words, regardless of
# what may be adjacent:  !"#&'()+,./:;<=>?@[]`{|}
export WORDCHARS='|*?-~\\$%^'


# ======== Java
function whichjava() {
    for cmd in 'which java' 'java -version' 'typeset -p JAVA_HOME IDEA_HOME IDEA_JDK'; do
        echo \# $cmd
        eval $cmd
        echo
    done
}

java_root=/usr/lib/jvm
if [[ -d $java_root ]]; then
    for home in ${java_root}/java-*-jdk*; do
        digits=${home##*java-};  digits=${digits%%-*}   # everything between the dashes
        suffix=${home##*jdk};    suffix=${suffix//-/_}  # everything after the jdk[-_]
        javaDigitsHome=JAVA${digits}_HOME${suffix}
        export $javaDigitsHome=$home
        # typeset $javaDigitsHome
        alias java${digits}${suffix}="PATH=\${PATH//\$JAVA_HOME/\$$javaDigitsHome}; JAVA_HOME=\$$javaDigitsHome; whichjava"
        if [[ -z "${suffix}" ]]; then
            eval export JAVA_HOME=\$${javaDigitsHome}  # keep the highest-numbered version
        fi
    done
    if [[ -n "$JAVA11_HOME" ]]; then
        JAVA_HOME=$JAVA11_HOME
    fi
    unset digits javaDigitsHome suffix
else
    export JAVA_HOME=/Library/Java/JavaVirtualMachines/amazon-corretto-11.jdk/Contents/Home
fi
unset java_root

prependPath ${JAVA_HOME}/bin

if [[ -d "${JAVA_HOME}_nodcevm" ]]; then
    IDEA_JDK=${JAVA_HOME}_nodcevm
fi

export JAVA16_HOME=/usr/lib32/jvm/java32-6-jdk
export JAVA18_AMD64_HOME=${JAVA8_HOME}


# # ======== Functions

alert() {
  if [[ $? -eq 0 ]]; then
    notify-send -t 3000 -i info Success\! "\n$1"
  else
    notify-send -t 5000 -i error Failed\! "\n$1"
    return 1
  fi
}

echoList() {
    local listName=$1; shift
    eval local contents=\$${listName}

    local debug=:
    local show_type=''
    local rm_row=
    local RS=${RS:-:}

    while [[ -n "$*" ]]; do
        case $1 in
            --debug)
                debug=
                echo "listName=$listName"
                echo "contents=$contents"
                shift
                ;;
            --help)
                echo PSCHAAF %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                echo --help      Show this screen
                echo --show-type Shows the type of the argument files
                echo --rm #      Removes item number # from the list and print the new value
                return
                ;;
            --rm)
                shift
                rm_row=$1
                shift
               ;;
            --show-type)
                show_type='file -L'
                shift
                ;;
           --*)
                echo Unrecognized option "$1"!
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    $debug echo '=====' contents=$contents

    $ifZsh echo " ${listName} has type ${(Pt)listName}"

    # save all AWK output to the end to avoid screen flicker
    echo -E ${contents} | awk '
    NR == 1 {split(file, files, " ")}
    {
      gsub("/c" ENVIRON["HOME"],"~")
      gsub(ENVIRON["HOME"],"~")
      dirname = $0
      carat = " "
      startColor = ""
      endColor = "[0m"
      for (idx in files) {  # note if any of the argument files are in this dir
        fullpath = $1 "/" files[idx]
        if (! system("test -f " fullpath)) {
            startColor = "[1;33m"
            matches = matches " " fullpath
            carat=">"
            break
        }
      }
      if (NR == rm_row) {
          startColor = sprintf("%s", "[101m")
      }
      output = output sprintf("\n%s%2d %s%s%s", carat, NR, startColor, dirname, endColor)
    }
    END {
        print output
        if (matches) {
            print ls matches "\n"
            system(ls matches)
            if (show_type) {
                print "\n" show_type matches "\n"
                system(show_type matches)
            }
        }
    }' RS=${RS} file="${*}" ls="/bin/ls \${LS_FLAGS} -Hl" rm_row="${rm_row:-999}" show_type=${show_type}

    if [[ -n $rm_row ]]; then
        contents=`echo $contents | awk 'NR != RM_ROW {printf ":" ""; print}' RM_ROW=$rm_row RS=${RS} ORS='' | sed -E 's/::+/:/g; s/^:|:$//g'`
        eval $listName=$contents # update the var
        echo Removed row $rm_row from $listName
        $debug echo "listName=$listName"
        $debug echo "contents=$contents"
    fi

    [[ $# -lt 1 ]] && return

    shift
    echo "\nIgnored extra arguments: '$*'!"
    return 1
}

echoVar() {
    local var
    for var; do
        echo -n "\n # ${var} has type ${(Pt)var}\n "
        typeset -p ${var} | sed 's/^typeset -x//'
    done
}

alias classpath='echoList CLASSPATH'
alias grep='command grep --extended-regexp --color'
alias fpath='echoList FPATH'
alias libpath='echoList LD_LIBRARY_PATH'
alias path='echoList PATH'

rubylib() {
    echoVar RUBYLIB
    echo
    local RUBYLIB=`ruby -e 'print $:.join(":")'`
    echoList RUBYLIB | sed 's/^.*has type.*/ Including implicit dirs:/'
}

ddu() {
    # show the size of each subdirectory
    find ${*:-.} -maxdepth 1 -type d -print0 | xargs -0 du -hs | sort -n
}

pcd() {
    # Change to the specified dir & remove starting place from dir stack
    cd "$@"; popd +1 2>/dev/null
}

alias term='echoVar TERM'

alias vpnc-connect='sudo vpnc-connect'
alias vpnc-disconnect='sudo vpnc-disconnect'

wcat()   {
	cat $(which $*)
}
wcd()    {
	cd $(which $*)
}
wfile()  {
	file $(which ${@}) 2>/dev/null || echo \'${@}\' not found
}
whence() {
	builtin whence -ac $*
}
wless()  {
	${PAGER} $(which ${@}) 2>/dev/null || echo \'${@}\' not found
}

# ======== ls Aliases and Functions
unalias l la ll ls lsd lld lsda lldarm d s p rd 2>/dev/null
alias l=/bin/ls
ifMacOS \
    && LS_FLAGS="${LS_FLAGS}G" \
    || LS_FLAGS="${LS_FLAGS}${LS_COLORS:+ --color}"

export LS="l ${LS_FLAGS}"
alias ls=${LS}

alias la='ls -A'
alias ll='ls -l'
alias lla='ls -Al'

alias llt='ls -lrt'
alias lr='ls -R'
lsd() {
    dir=${1}${1:+/}
    l ${LS_FLAGS/F/} -d ${dir}*/
}
lld() {
    dir=${1:-.}
    ls -ld ${dir}/*/
}
lsda() {
    if [[ $# -eq 0 ]]; then
	    l ${LS_FLAGS/F/} -ld */(D)
    else
        for dir in ${*}; do
            echo
            ls -d $dir
            l ${LS_FLAGS/F/} -ld ${dir}/*/(D)
        done
    fi
}

alias llda='lsda -l'

lsf() {
    local x
    for x in ${*:-*}; do
        echo `file -N -- $x`:`ls -d -- $x` | sed 's/^[^:]*: //'
    done | column -t -s ':'
}

# ======== Aliases
alias ..='pushd ..'
alias ...="pushd ../.."
alias du='du -h'
alias perf='./perf -Ddir.user=pschaaf'
alias rm='rm -i'
alias root='sudo -u root ZDOTDIR=/home/pschaaf zsh -il'
alias tree="tree -a --dirsfirst"

case ${UNAME} in
    CYGWIN*)
        source ~/etc/rc/zshenv.cygwin
        ;;
    MINGW32_NT*)
        # Change the driveLetter+colon combo into forwardSlash+driveLetter, swap
        # all slashes, replace semicolons with colons. We can't use cygpath.exe
        # for this because it collapses all references to $CYGROOT to /, which
        # doesn't work outside of Cygwin (since $CYGWIN won't be the root
        # directory)
        CYGROOT=`echo $CYGROOT | sed 's~\([a-zA-Z]\):~/\1~g; s~\\\\~/~g; s~;~:~g'`
        alias cygpath=${CYGROOT}/bin/cygpath.exe

        fixDOSPathIn ANT_HOME GIT_PATH JAVA_HOME
        ;;
    *)
        ;;
esac

#cleanList PATH
cleanList CLASSPATH

# Guidewire
if [[ -f ~/dotfiles/secrets ]]; then
    source ~/dotfiles/secrets
fi
export TEAMCITY_USER=$USER
export ARTIFACTORY_USERNAME=$USER

if [[ -n "$CD_TO" ]]; then
    builtin cd "$CD_TO" && unset CD_TO
fi

# Move this heredoc around in the file to temporarily disable sections
# of code. Make sure to keep the opening tag first, and the closing tag
# against the left margin on a line by itself.
: <<DEBUG_NO_EXEC
DEBUG_NO_EXEC
set +x
