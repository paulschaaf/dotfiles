<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Enscript Output</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<H1>Contents</H1>
<OL>
  <LI><A HREF="#file1">lisp/zork</A>
  <LI><A HREF="#file2">lisp/zork/advflow.txt</A>
  <LI><A HREF="#file3">lisp/zork/all.lisp</A>
  <LI><A HREF="#file4">lisp/zork/classes.lisp</A>
  <LI><A HREF="#file5">lisp/zork/directedgraph.lisp</A>
  <LI><A HREF="#file6">lisp/zork/dungeon1.lisp</A>
  <LI><A HREF="#file8">lisp/zork/hierarchy.txt</A>
  <LI><A HREF="#file9">lisp/zork/making.lisp</A>
  <LI><A HREF="#file10">lisp/zork/meta.lisp</A>
  <LI><A HREF="#file11">lisp/zork/parser.lisp</A>
  <LI><A HREF="#file12">lisp/zork/printing.lisp</A>
  <LI><A HREF="#file13">lisp/zork/taxonomy.txt</A>
  <LI><A HREF="#file14">lisp/zork/transcript.zork1</A>
  <LI><A HREF="#file15">lisp/zork/zorksim.lisp</A>
</OL>
<HR>
<A NAME="file1">
<H1>lisp/zork 1/14</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
</PRE>
<HR>
<A NAME="file2">
<H1>lisp/zork/advflow.txt 2/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
Describe Location
- List room features (describe)
- List obvious escape routes [There are doors to the North <B><FONT COLOR="#A020F0">and</FONT></B> to the East.]
- List observable objects [Sitting on the table is a candlestick.]
- Notify of any change in status of Adventurer [You begin to feel hungry.]

Prompt for Input
- Accept statement
- Break into manageable parts
  - Break the sentence after commas <B><FONT COLOR="#A020F0">and</FONT></B> (sometimes) conjunctions <B><FONT COLOR="#A020F0">and</FONT></B> treat each as a separate
    part.
- Check part for unrecognized terms (incl. interjections <B><FONT COLOR="#A020F0">and</FONT></B> pronouns)
  - Notify User [I don't know the word . . .]
  - GOTO Section II.
- Identify Action Verb, Direct Object, (usu. noun/adjective combo.), Preposition , <B><FONT COLOR="#A020F0">and</FONT></B> the
  Indirect Object (usu. noun/adjective combo.). [Put the bloody knife on the brown table.]
- Report any incomplete sentence
  - GOTO Sect. II
- Discard any unecessary parts of speech (adverbs {very}, participles {the})
- Loop to Pgph. C for each part of input left

Process each part of the sentence, <B><FONT COLOR="#A020F0">and</FONT></B> act upon it
- Announce (<B><FONT COLOR="#A020F0">and</FONT></B> record) any change in status of an object [You <B><FONT COLOR="#A020F0">throw</FONT></B> the Lamp against the wall,
  breaking it.]
  - If any change in location of object, update record [You put the chicken in the barrel.]
- Announce (<B><FONT COLOR="#A020F0">and</FONT></B> record) any change in status of the room [As you push the beam, the ceiling
  begins to sag.]
- Announce (<B><FONT COLOR="#A020F0">and</FONT></B> record) any change in status of the Adventurer [Drinking the liquid makes you
  feel dizzy.]
  - Record change in location of Adventurer. GOTO Sect. I.
- Provide the information requested [You are in perfect health.]
- Perform the operation requested [Insert Save disk in drive A.]
</PRE>
<HR>
<A NAME="file3">
<H1>lisp/zork/all.lisp 3/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
(defmethod nosuch ((player IsPlayer) name)
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;You don't see any ~A here.~&amp;&quot;</FONT></B> (string-downcase name)))

(defmethod nosuch ((player IsPlayer) (obj (eql 'it)))
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;You'll have to be more specific.~&amp;&quot;</FONT></B>))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Exiting
</FONT></I>
<I><FONT COLOR="#B22222">;(defmethod north ((player IsPlayer))
</FONT></I><I><FONT COLOR="#B22222">;  (let ((destination (traverse (location player) 'north)))
</FONT></I><I><FONT COLOR="#B22222">;    (if destination
</FONT></I><I><FONT COLOR="#B22222">;	(setf (location player) destination)
</FONT></I><I><FONT COLOR="#B22222">;      (player-format player &quot;You can't go that way.&quot;))))
</FONT></I>
(defmacro defdirection (direction)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((dest (gensym)))
    `(defun ,direction (player)
       (<B><FONT COLOR="#A020F0">let</FONT></B> ((,dest (traverse (location player) ',direction)))
	 (<B><FONT COLOR="#A020F0">if</FONT></B> ,dest
	     (setf (location player) ,dest)
	   (player-format player <B><FONT COLOR="#BC8F8F">&quot;You can't go that way.&quot;</FONT></B>))))))

(defdirection up)
(defdirection down)

(defdirection in)
(defdirection out)

(defdirection north)
(defdirection east)
(defdirection south)
(defdirection west)

(defdirection northeast)
(defdirection southeast)
(defdirection northwest)
(defdirection southwest)

(def-method-alias north n)
(def-method-alias south s)
(def-method-alias east e)
(def-method-alias west w)
(def-method-alias northeast ne)
(def-method-alias northwest nw)
(def-method-alias southeast se)
(def-method-alias southwest sw)
(def-method-alias up u)
(def-method-alias down d)

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Dropping
</FONT></I>
(defmethod drop ((player IsPlayer) (objs (eql 'all)))
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((all (contents player)))
    (<B><FONT COLOR="#A020F0">if</FONT></B> all
	(drop player all)
      (player-format player <B><FONT COLOR="#BC8F8F">&quot;You have nothing to drop!&quot;</FONT></B>))))

(defmethod drop ((player IsPlayer) (objs cons))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (second objs)
      (dolist (each objs nil)
	(player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;~A: &quot;</FONT></B> each)
	(drop player each))
    (drop player (first objs))))

(defmethod drop (player (obj HasLocation))
  (move-obj player obj (location obj) (location player)))

(defmethod move-obj ((player IsPlayer) (obj HasLocation) (from IsAnimal) (to IsRoom))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (eql player from)
      (<B><FONT COLOR="#A020F0">progn</FONT></B>
	(setf (location obj) (location player))
	(player-format player <B><FONT COLOR="#BC8F8F">&quot;Dropped.&quot;</FONT></B>))
    (player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;Just how do you propose to do that?&quot;</FONT></B>)))

(defmethod move-obj ((player IsPlayer) (obj HasLocation) (from HasContents) (to IsRoom))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (is-carrying player from)
      (player-format player <B><FONT COLOR="#BC8F8F">&quot;You must first remove it from the ~A.&quot;</FONT></B>
	      (name from))
    (player-format player <B><FONT COLOR="#BC8F8F">&quot;You are not carrying it.&quot;</FONT></B>)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Taking
</FONT></I>
(defmethod take ((player IsPlayer) (objs (eql 'all)))
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((all (remove player (contents (location player)))))
    (<B><FONT COLOR="#A020F0">if</FONT></B> all
	(take player all)
      (player-format player <B><FONT COLOR="#BC8F8F">&quot;There is nothing to take!&quot;</FONT></B>))))

(defmethod take ((player IsPlayer) (objs cons))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (second objs)
      (dolist (each objs nil)
	(player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;~A: &quot;</FONT></B> each)
	(take player each))
    (take player (first objs))))

(defmethod take (player (obj HasLocation))
  (move-obj player obj (location obj) player))

(defmethod move-obj ((player IsPlayer) (obj IsImmobile) from (to IsPlayer))
  (player-format player (immobile-because obj)))

(defmethod move-obj (player obj from to)
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;You can't move that!~&amp;&quot;</FONT></B>))

(defmethod move-obj ((player IsPlayer) (obj IsImmobile) (from IsPlayer) to)
  (player-format player (immobile-because obj)))

(defmethod move-obj ((player IsPlayer) (obj HasLocation) (from IsAnimal) (to IsPlayer))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (eql from to)
      (player-format player <B><FONT COLOR="#BC8F8F">&quot;You are already carrying it.&quot;</FONT></B>)
    (player-format player <B><FONT COLOR="#BC8F8F">&quot;If you want to fight the ~A, just say so.&quot;</FONT></B> (name from))))

(defmethod move-obj ((player IsPlayer) (obj HasLocation) (from HasContents) (to IsPlayer))
  (setf (location obj) player)
  (<B><FONT COLOR="#A020F0">if</FONT></B> (is-carrying player from)
      (<B><FONT COLOR="#A020F0">progn</FONT></B>
	(player-format player <B><FONT COLOR="#BC8F8F">&quot;You remove the ~A from the ~A.&quot;</FONT></B> 
		       (name obj) 
		       (name from)))
    (player-format player <B><FONT COLOR="#BC8F8F">&quot;Taken.&quot;</FONT></B> (name obj))))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Reachability
</FONT></I>
(defmethod can-reach ((animal IsAnimal) obj)
  (can-reach-in animal obj (location obj)))

(defmethod can-reach ((animal IsAnimal) (obj isGame))
  (eql (game animal) obj))

(defmethod can-reach-in ((animal IsAnimal) obj (container HasContents))
  (can-reach-in animal container (location container)))

(defmethod can-reach-in <B><FONT COLOR="#5F9EA0">:around</FONT></B> ((animal IsAnimal) obj (container IsCloseable))
  (<B><FONT COLOR="#A020F0">and</FONT></B> (is-open container)
       (call-next-method animal obj container)))

(defmethod can-reach-in ((animal IsAnimal) obj (container IsAnimal))
  (eql container animal))

(defmethod can-reach-in ((animal IsAnimal) obj (container IsRoom))
  (eql container (room-with animal)))

(defmethod can-reach-in ((animal IsAnimal) obj (container IsDungeon))
  (eql container (dungeon-with animal)))

(defmethod can-reach-in ((animal IsAnimal) obj (container IsGame))
  (eql container (game animal)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Opening and Closing
</FONT></I>
(defmethod open-container <B><FONT COLOR="#5F9EA0">:around</FONT></B> ((player IsPlayer) (obj IsPiece))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (can-reach player obj)
      (call-next-method player obj)
    (player-format player <B><FONT COLOR="#BC8F8F">&quot;You aren't carrying the ~A.&quot;</FONT></B> (name obj))))

(defmethod open-container ((player IsPlayer) (obj IsPiece))
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;You can't open ~A!&quot;</FONT></B> (a-<B><FONT COLOR="#A020F0">or</FONT></B>-an-then obj)))

(defmethod close-container ((player IsPlayer) (obj IsPiece))
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;You can't close ~A!&quot;</FONT></B> (a-<B><FONT COLOR="#A020F0">or</FONT></B>-an-then obj)))

(defreduction open-container (animal (objs cons)) objs)

(defreduction close-container (animal (objs cons)) objs)

(defmethod open-container ((player IsPlayer) (container IsCloseable))
  <I><FONT COLOR="#B22222">; must be reachable
</FONT></I>  (<B><FONT COLOR="#A020F0">if</FONT></B>-open container
      (player-format player <B><FONT COLOR="#BC8F8F">&quot;It is already open!&quot;</FONT></B>)
    (<B><FONT COLOR="#A020F0">progn</FONT></B>
      (setf (is-open container) T)
      (<B><FONT COLOR="#A020F0">if</FONT></B> (contents container)
	  (<B><FONT COLOR="#A020F0">progn</FONT></B> 
	    (player-format player <B><FONT COLOR="#BC8F8F">&quot;Opening the ~A reveals &quot;</FONT></B> container)
	    (print-object-list (contents container) t)
	    
	    <I><FONT COLOR="#B22222">; If the list has more than one item, then &quot;it&quot; is ambiguous
</FONT></I>	    <I><FONT COLOR="#B22222">; &quot;it&quot; is unambiguous for one item or empty container
</FONT></I>	    (<B><FONT COLOR="#A020F0">if</FONT></B> (second (contents container))
		(setf (it player) nil)
	      (setf (it player) (first (contents container)))))
	(player-format player <B><FONT COLOR="#BC8F8F">&quot;Opened.&quot;</FONT></B>)))))

(defmethod close-container ((player IsPlayer) (container IsCloseable))
  <I><FONT COLOR="#B22222">; must be reachable
</FONT></I>  (<B><FONT COLOR="#A020F0">if</FONT></B>-open container
      (<B><FONT COLOR="#A020F0">progn</FONT></B>
	(setf (is-open container) nil)
	(player-format player <B><FONT COLOR="#BC8F8F">&quot;Closed.&quot;</FONT></B>))
    (player-format player <B><FONT COLOR="#BC8F8F">&quot;It is already closed!&quot;</FONT></B>)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Structure
</FONT></I>
(defmethod game ((obj HasLocation))
  (game (location obj)))

(defmethod game ((obj IsGame))
  obj)

(defmethod dungeon-with ((obj HasLocation))
  (dungeon-with (location obj)))

(defmethod dungeon-with ((dungeon IsDungeon))
  dungeon)

(defmethod dungeon-in ((game IsGame) label)
  (find-in-shallow game label))

(defmethod room-in ((game IsGame) label)
  (room-in (contents game) label))

(defmethod room-in ((dungeon IsDungeon) label)
  (find-in-shallow dungeon label))

(defmethod room-in ((dungeon IsDungeon) (room IsRoom))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (eq dungeon (dungeon room))
      room
    nil))

(defmethod room-in ((places cons) label)
  (<B><FONT COLOR="#A020F0">or</FONT></B> (room-in (car places) label)
      (room-in (cdr places) label)))

(defmethod room-with ((obj HasLocation))
  (room-with (location obj)))

(defmethod room-with ((room IsRoom))
  room)

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Containership
</FONT></I>
<I><FONT COLOR="#B22222">;(defmethod has-in-hand ((place HasContents) obj)
</FONT></I><I><FONT COLOR="#B22222">;  (eql place (location obj)))
</FONT></I>
(defmethod is-carrying ((animal IsAnimal) obj)
  (is-in obj animal))

(defmethod is-in (obj (cont cons))
  (<B><FONT COLOR="#A020F0">or</FONT></B> (is-in obj (car cont))
      (is-in obj (cdr cont))))

(defmethod is-in (obj1 obj2)
  nil)

(defmethod is-in ((obj HasLocation) (cont HasContents))
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((obj-loc (location obj)))
    (<B><FONT COLOR="#A020F0">and</FONT></B> obj-loc                      <I><FONT COLOR="#B22222">; if obj is contained, and
</FONT></I>	 (<B><FONT COLOR="#A020F0">or</FONT></B> (eql cont obj-loc)       <I><FONT COLOR="#B22222">; either it is directly in cont
</FONT></I>	     (is-in obj-loc cont))))) <I><FONT COLOR="#B22222">; or its container is
</FONT></I>
(defmethod is-in (obj (cont HasContents))
  (<B><FONT COLOR="#A020F0">or</FONT></B> (first (member obj (contents cont)))
      (is-in obj (contents cont))))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Finding
</FONT></I>
<I><FONT COLOR="#B22222">;(defmethod find-for ((player IsPlayer) (obj (eql 'all)))
</FONT></I><I><FONT COLOR="#B22222">;  'all)
</FONT></I>
(defmethod find-for ((player IsPlayer) (obj (eql 'it)))
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((real-obj (it player)))
    (<B><FONT COLOR="#A020F0">if</FONT></B> real-obj (player-format player <B><FONT COLOR="#BC8F8F">&quot;[The ~A] &quot;</FONT></B> (name real-obj)))
    (find-for player real-obj)))

(defmethod find-for ((animal IsAnimal) obj)
  (<B><FONT COLOR="#A020F0">or</FONT></B> (find-in animal obj)
      (find-in (location animal) obj)))

(defmethod find-in ((places cons) obj)
  (<B><FONT COLOR="#A020F0">or</FONT></B> (find-in (car places) obj)
      (find-in (cdr places) obj)))

(defmethod find-in <B><FONT COLOR="#5F9EA0">:around</FONT></B> ((place IsCloseable) obj)
  (<B><FONT COLOR="#A020F0">if</FONT></B>-open place
	   (call-next-method place obj)
	   nil))

(defmethod find-in ((place HasContents) obj)
  (<B><FONT COLOR="#A020F0">or</FONT></B> (find-in-shallow place obj)
      (find-in (contents place) obj)))

(defmethod find-in (place label)
  nil)

(defmethod find-in-shallow ((places cons) obj)
  (<B><FONT COLOR="#A020F0">or</FONT></B> (find-in-shallow (car places) obj)
      (find-in-shallow (cdr places) obj)))

(defmethod find-in-shallow ((place HasContents) (obj IsPiece))
  (first (member obj (contents place))))

(defmethod find-in-shallow ((place HasContents) (label symbol))
  (find-in-shallow place (symbol-name label)))

(defmethod find-in-shallow ((place HasContents) (name string))
  (debug-<B><FONT COLOR="#A020F0">do</FONT></B> place 
	    (<B><FONT COLOR="#A020F0">progn</FONT></B> (format t <B><FONT COLOR="#BC8F8F">&quot;Searching ~A.~&amp;&quot;</FONT></B> (name place))
		   (dolist (each (contents place) nil)
		     (format t <B><FONT COLOR="#BC8F8F">&quot;    ~A~&amp;&quot;</FONT></B> (label each)))
		   (format t <B><FONT COLOR="#BC8F8F">&quot;~2&amp;&quot;</FONT></B>)))
  (find-<B><FONT COLOR="#A020F0">if</FONT></B> #'(<B><FONT COLOR="#A020F0">lambda</FONT></B> (x)
	       (string-equal name (name x)))
	   (contents place)))

(defmethod find-in-shallow ((place (eql nil)) label)
  nil)

(defmethod find-in-shallow (place label)
  nil)

(defmethod find-in-shallow (place (name string))
  (find-in-shallow place (intern name)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- User Commands
</FONT></I>
(defmethod state ((game IsGame))
  <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)

(defmethod user-quitp ((player IsPlayer))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (debug-on player)
      (toggle-debug-mode player)
    (<B><FONT COLOR="#A020F0">progn</FONT></B>
      (score player)
      (<B><FONT COLOR="#A020F0">if</FONT></B> (eq 'y 'y)<I><FONT COLOR="#B22222">;(prompt-player game &quot;Really user-quitp?&quot;))
</FONT></I>	  (exit)))))

(def-method-alias user-quitp q)

(defmethod enter <B><FONT COLOR="#5F9EA0">:around</FONT></B> ((player IsPlayer) (game IsGame))
  (call-next-method player game)
  (<B><FONT COLOR="#A020F0">do</FONT></B> ((player-input (next-command player) (next-command player)))
      (())
    (eval-input player player-input)))

(defmethod score ((player IsPlayer))
    (player-format player
	    <B><FONT COLOR="#BC8F8F">&quot;Your score is ~A out of a possible ~A.~&amp;This gives you the rank of novice.&quot;</FONT></B>
	    (current-score player)
	    (max-score (game player))))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; --------------------
</FONT></I>
<I><FONT COLOR="#B22222">;(defmethod command-separator ((str string))
</FONT></I><I><FONT COLOR="#B22222">;  (or (eq str &quot;.&quot;) (eq str &quot;;&quot;) (eq str &quot;then &quot;)))
</FONT></I>
<I><FONT COLOR="#B22222">;(defun replace-string (string target replacement &amp;optional &amp;key (start1 0) (start2 0) (start3 0))
</FONT></I><I><FONT COLOR="#B22222">;  (replace target replacement
</FONT></I><I><FONT COLOR="#B22222">;	   :start1 (search target string
</FONT></I><I><FONT COLOR="#B22222">;			   :start1 start2
</FONT></I><I><FONT COLOR="#B22222">;			   :start2 start1)
</FONT></I><I><FONT COLOR="#B22222">;	   :start2 start3))
</FONT></I></PRE>
<HR>
<A NAME="file4">
<H1>lisp/zork/classes.lisp 4/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
(load <B><FONT COLOR="#BC8F8F">&quot;directedgraph.lisp&quot;</FONT></B>)

<I><FONT COLOR="#B22222">; -----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Primitive Properties
</FONT></I>
(defclass HasLabel ()
  ((debug-on      <B><FONT COLOR="#5F9EA0">:allocation</FONT></B> <B><FONT COLOR="#5F9EA0">:class</FONT></B>
		  <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> debug-on     <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:debug-on</FONT></B>
		  <B><FONT COLOR="#5F9EA0">:initform</FONT></B> nil)
   (label         <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> label        <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:label</FONT></B>
		  <B><FONT COLOR="#5F9EA0">:initform</FONT></B> 'nolabel)))

(defclass HasLocation ()
  ((location      <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> location     <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:location</FONT></B>
		  <B><FONT COLOR="#5F9EA0">:initform</FONT></B> nil)))

(defclass HasContents ()
  ((contents      <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> contents
		  <B><FONT COLOR="#5F9EA0">:initform</FONT></B> nil)))

(defclass IsCloseable ()
  ((is-open       <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> is-open
		  <B><FONT COLOR="#5F9EA0">:initform</FONT></B> nil)))

(defclass HasDescription ()
  ((description   <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> description  <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:description</FONT></B>)))

(defclass HasName (HasLabel)
  ())

(defmethod name ((obj HasName))
  (symbol-name (label obj)))

(defmethod (setf name) (string (obj HasName))
  (setf (label obj) (intern (copy-seq string))))

(defclass IsMobile ()
  (()))

(defclass IsImmobile ()
  ((immobile-because <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> immobile-because <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:immobile-because</FONT></B>
		     <B><FONT COLOR="#5F9EA0">:initform</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;remains fixed to the floor.&quot;</FONT></B>)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Object Types
</FONT></I>
(defclass IsExaminable (HasName HasDescription HasLocation) ())
(defclass IsPlace      (HasContents IsExaminable) ())
(defclass ExitPath     (HasDescription arc) ())

(defclass IsPiece      (IsMobile IsExaminable) ())
(defclass IsBag        (IsCloseable HasContents IsPiece) ())

(defclass IsFixture    (IsImmobile IsExaminable) ())
(defclass IsContainer  (IsCloseable HasContents IsFixture) ())

(defclass IsDungeon    (IsPlace)
   ((entrance          <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> entrance)))

(defclass IsAnimal     (IsPlace) ())
(defclass IsPlayer     (IsAnimal)
  ((game               <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> game        <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:game</FONT></B>)
   (it                 <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> it
		       <B><FONT COLOR="#5F9EA0">:initform</FONT></B> nil)
   (prompt             <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> prompt      <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:prompt</FONT></B>
		       <B><FONT COLOR="#5F9EA0">:initform</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;&gt;&quot;</FONT></B>)
   (current-score      <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> current-score
		       <B><FONT COLOR="#5F9EA0">:initform</FONT></B> 0)
   (display            <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> display     <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:display</FONT></B>
		       <B><FONT COLOR="#5F9EA0">:initform</FONT></B> t)
   (verbose            <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> verbose     <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:verbose</FONT></B>
		       <B><FONT COLOR="#5F9EA0">:initform</FONT></B> t)))

(defmethod (setf it) <B><FONT COLOR="#5F9EA0">:after</FONT></B> (obj (player IsAnimal))
  (debug-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;'it set to ~A~&amp;&quot;</FONT></B> obj))

(defclass IsRoom       (IsPlace node) ())

(defclass IsGame       (HasContents HasName HasDescription)
  ((max-score          <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> max-score   <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:max-score</FONT></B>
		       <B><FONT COLOR="#5F9EA0">:initform</FONT></B> 100)
   (entrance           <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> entrance)))

(defmethod (setf entrance) ((name symbol) (dungeon IsDungeon))
  (setf (entrance dungeon) (room-in dungeon name)))

(defmethod (setf entrance) ((name symbol) (game IsGame))
  (setf (entrance game) (dungeon-in game name)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Opening / Closing
</FONT></I>
(defmethod is-open (obj)
  T)

(defmethod is-closed (obj)
  (not (is-open obj)))

(defmethod (setf is-closed) (value (obj IsCloseable))
  (princ value)
  (setf (is-open obj) (not value)))

(defmacro <B><FONT COLOR="#A020F0">if</FONT></B>-closed (obj then &amp;optional else)
  `(<B><FONT COLOR="#A020F0">if</FONT></B>-open ,obj ,else ,then))

(defmacro <B><FONT COLOR="#A020F0">if</FONT></B>-open (obj then &amp;optional else)
  `(<B><FONT COLOR="#A020F0">if</FONT></B> (is-open ,obj)
       ,then
     ,else))

(defmethod is-empty ((container HasContents))
  (endp (contents container)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Location
</FONT></I>
(defmethod put-in (in obj)
  (format t <B><FONT COLOR="#BC8F8F">&quot;~&amp;put-in ~A ~A&quot;</FONT></B> in obj)
  (put-in (find-obj in) obj))

(defmethod put-in ((in HasContents) obj)
  (put-in in (find-obj obj)))

(defmethod put-in ((in HasContents) (obj HasLocation))
  (setf (location obj) in))

(defmethod find-obj (obj)
  (find-in *dungeon* obj))

(defmethod location (obj)
  (location (find-obj obj)))

(defmethod (setf location) (value obj)
  (setf (location (find-obj obj)) value))

(defmethod (setf location) <B><FONT COLOR="#5F9EA0">:around</FONT></B> ((dest HasContents) (obj IsExaminable))
  <B><FONT COLOR="#BC8F8F">&quot;Set the bi-directional pointers between an object and its container.&quot;</FONT></B>
  <I><FONT COLOR="#B22222">;(format t &quot;~&amp;put ~A into ~A&quot; obj dest)
</FONT></I>  (<B><FONT COLOR="#A020F0">let</FONT></B>* ((src (location obj))
	(old-contents (<B><FONT COLOR="#A020F0">if</FONT></B> src (contents src))))
    (<B><FONT COLOR="#A020F0">if</FONT></B> old-contents                <I><FONT COLOR="#B22222">; remove the link from old parent
</FONT></I>	(setf (contents src) (remove obj old-contents))))
  (push obj (contents dest))        <I><FONT COLOR="#B22222">; establish link from new parent
</FONT></I>  (call-next-method dest obj))

(defmethod (setf location) <B><FONT COLOR="#5F9EA0">:after</FONT></B> ((dest IsRoom) (player IsPlayer))
  (look-at player dest))

(defmethod enter ((player IsPlayer) (location IsRoom))
  (setf (location player) location))

<I><FONT COLOR="#B22222">;(defmethod enter ((player IsPlayer) (location IsDungeon))
</FONT></I><I><FONT COLOR="#B22222">;  (enter player (entrance location)))
</FONT></I>
(defmethod enter <B><FONT COLOR="#5F9EA0">:before</FONT></B> ((player IsPlayer) (location IsGame))
  (setf (game player) location))

(defmethod enter ((player IsPlayer) location)
  (look-at player location)
  (enter player (entrance location)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Debugging
</FONT></I>
<I><FONT COLOR="#B22222">;(defmethod (setf debug-on) :after (value (obj HasLabel))
</FONT></I><I><FONT COLOR="#B22222">;  (if value
</FONT></I><I><FONT COLOR="#B22222">;      (format t &quot;Debugging is now on.&quot;)
</FONT></I><I><FONT COLOR="#B22222">;    (format t &quot;Debugging is now off.&quot;)))
</FONT></I>
(defmethod prompt <B><FONT COLOR="#5F9EA0">:around</FONT></B> ((player IsPlayer))
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((superprompt (call-next-method player)))
    (<B><FONT COLOR="#A020F0">if</FONT></B> (debug-on player)
	(concatenate 'string (state (game player)) <B><FONT COLOR="#BC8F8F">&quot;debug &quot;</FONT></B> superprompt)
      superprompt)))

(defmacro debug-<B><FONT COLOR="#A020F0">do</FONT></B> (labeled function &amp;optional else)
  `(<B><FONT COLOR="#A020F0">if</FONT></B> (debug-on ,labeled)
       ,function
     ,else))

(defmethod debug-format ((player IsPlayer) &amp;rest rest)
  (debug-<B><FONT COLOR="#A020F0">do</FONT></B> player (apply 'player-format player rest)))

(<B><FONT COLOR="#A020F0">defun</FONT></B> <B><FONT COLOR="#0000FF">toggle-debug-mode</FONT></B> (obj)
  (setf (debug-on obj) (not (debug-on obj))))
</PRE>
<HR>
<A NAME="file5">
<H1>lisp/zork/directedgraph.lisp 5/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
(defclass node ()
  ((name        <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> name         <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:name</FONT></B>
		<B><FONT COLOR="#5F9EA0">:initform</FONT></B> nil)
   (arcs        <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> arcs
	        <B><FONT COLOR="#5F9EA0">:initform</FONT></B> (make-hash-table))))

<I><FONT COLOR="#B22222">; arcs are unidirectional
</FONT></I>(defclass arc ()
  ((destination <B><FONT COLOR="#5F9EA0">:accessor</FONT></B> destination  <B><FONT COLOR="#5F9EA0">:initarg</FONT></B> <B><FONT COLOR="#5F9EA0">:to</FONT></B>
		<B><FONT COLOR="#5F9EA0">:initform</FONT></B> nil)))

<I><FONT COLOR="#B22222">; arcs are labeled uniquely for each node 
</FONT></I>(defmethod make-arc (&amp;key labeled (from node) (to node))
  (setf (gethash labeled (arcs from)) 
	(make-instance 'arc <B><FONT COLOR="#5F9EA0">:to</FONT></B> to)))

(defmethod is-adjacent ((a node) (b node))
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((answer nil))
    (maphash #'(<B><FONT COLOR="#A020F0">lambda</FONT></B> (key value)
		 (<B><FONT COLOR="#A020F0">if</FONT></B> (eq b (destination value))
		     (setf answer key)))
	     (arcs a))
    answer))

(defmethod traverse ((from node) direction)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((anArc (gethash direction (arcs from))))
    (<B><FONT COLOR="#A020F0">if</FONT></B> anArc
	(destination anArc))))

(defmethod print-object ((aNode node) str)
  (format str <B><FONT COLOR="#BC8F8F">&quot;&lt;~A&gt;&quot;</FONT></B> (name aNode)))

'(<B><FONT COLOR="#A020F0">defun</FONT></B> <B><FONT COLOR="#0000FF">test</FONT></B> ()
  (setf father (make-instance 'node <B><FONT COLOR="#5F9EA0">:name</FONT></B>  'Paul)
	mother (make-instance 'node <B><FONT COLOR="#5F9EA0">:name</FONT></B>  'Pat)
	paul   (make-instance 'node <B><FONT COLOR="#5F9EA0">:name</FONT></B>  'Paul)
	chris  (make-instance 'node <B><FONT COLOR="#5F9EA0">:name</FONT></B>  'Chris))
  (make-arc <B><FONT COLOR="#5F9EA0">:labeled</FONT></B> 'child   <B><FONT COLOR="#5F9EA0">:from</FONT></B> father <B><FONT COLOR="#5F9EA0">:to</FONT></B> chris)
  (make-arc <B><FONT COLOR="#5F9EA0">:labeled</FONT></B> 'child   <B><FONT COLOR="#5F9EA0">:from</FONT></B> father <B><FONT COLOR="#5F9EA0">:to</FONT></B> paul)
  (make-arc <B><FONT COLOR="#5F9EA0">:labeled</FONT></B> 'child   <B><FONT COLOR="#5F9EA0">:from</FONT></B> mother <B><FONT COLOR="#5F9EA0">:to</FONT></B> chris)
  (make-arc <B><FONT COLOR="#5F9EA0">:labeled</FONT></B> 'child   <B><FONT COLOR="#5F9EA0">:from</FONT></B> mother <B><FONT COLOR="#5F9EA0">:to</FONT></B> paul)
  (make-arc <B><FONT COLOR="#5F9EA0">:labeled</FONT></B> 'parent  <B><FONT COLOR="#5F9EA0">:from</FONT></B> chris  <B><FONT COLOR="#5F9EA0">:to</FONT></B> father)
  (make-arc <B><FONT COLOR="#5F9EA0">:labeled</FONT></B> 'parent  <B><FONT COLOR="#5F9EA0">:from</FONT></B> chris  <B><FONT COLOR="#5F9EA0">:to</FONT></B> mother)
  (make-arc <B><FONT COLOR="#5F9EA0">:labeled</FONT></B> 'parent  <B><FONT COLOR="#5F9EA0">:from</FONT></B> paul   <B><FONT COLOR="#5F9EA0">:to</FONT></B> father)
  (make-arc <B><FONT COLOR="#5F9EA0">:labeled</FONT></B> 'parent  <B><FONT COLOR="#5F9EA0">:from</FONT></B> paul   <B><FONT COLOR="#5F9EA0">:to</FONT></B> mother)
    
  (format t <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (is-adjacent father paul))
  (format t <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (is-adjacent mother paul))
  (format t <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (is-adjacent paul mother))
  (format t <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (is-adjacent paul father))

  (format t <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (is-adjacent father chris))
  (format t <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (is-adjacent mother chris))
  (format t <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (is-adjacent chris mother))
  (format t <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (is-adjacent chris father)))
</PRE>
<HR>
<A NAME="file6">
<H1>lisp/zork/dungeon1.lisp 6/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Rooms
</FONT></I>
(make-room <B><FONT COLOR="#BC8F8F">&quot;West of House&quot;</FONT></B>
<B><FONT COLOR="#BC8F8F">&quot;You are standing in an open field west of a white house, with a boarded front
door.&quot;</FONT></B>)

(setf (entrance *dungeon*) '|West of House|)

(make-room <B><FONT COLOR="#BC8F8F">&quot;North of House&quot;</FONT></B>
<B><FONT COLOR="#BC8F8F">&quot;You are facing the north side of a white house. There is no door here, and all the windows are boarded up. To the north a narrow path winds through the trees.&quot;</FONT></B>)

(make-room <B><FONT COLOR="#BC8F8F">&quot;Behind House&quot;</FONT></B>
<B><FONT COLOR="#BC8F8F">&quot;You are behind the white house. A path leads into the forest to the east.&quot;</FONT></B>)

(make-room <B><FONT COLOR="#BC8F8F">&quot;Kitchen&quot;</FONT></B>
<B><FONT COLOR="#BC8F8F">&quot;You are in the kitchen of the white house. A table seems to have been used recently for the preparation of food. A dark chimney leads down.&quot;</FONT></B>)

(make-room <B><FONT COLOR="#BC8F8F">&quot;Living Room&quot;</FONT></B>
<B><FONT COLOR="#BC8F8F">&quot;You are in the living room. There is a wooden door with strange gothic lettering to the west, which appears to be nailed shut, a trophy case, and a large oriental rug in the center of the room.&quot;</FONT></B>)

(setf *attic* (make-room <B><FONT COLOR="#BC8F8F">&quot;Attic&quot;</FONT></B>
<B><FONT COLOR="#BC8F8F">&quot;This is the attic.&quot;</FONT></B>))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Paths
</FONT></I>
(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|West of House|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'path
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(north)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|North of House|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|North of House|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'path
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(west)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|West of House|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|North of House|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'path
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(east)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|Behind House|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|Behind House|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'path
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(north)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|North of House|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>  <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|Behind House|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   '|In one corner of the house there is a small window.|
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(in west)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|Kitchen|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;The window is slightly ajar&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|Kitchen|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'window
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(out east)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|Behind House|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;To the east is a small window which is open.&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|Kitchen|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'doorway
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(west)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|Living Room|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;A doorway leads to the west.&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|Kitchen|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'staircase
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(up)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|Attic|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;A dark staircase can be seen leading upward.&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> #[Living Room]
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'doorway
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(east)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|Kitchen|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;There is a doorway to the east.&quot;</FONT></B>)

(make-path <B><FONT COLOR="#5F9EA0">:from</FONT></B> '|Attic|
  <B><FONT COLOR="#5F9EA0">:type</FONT></B>   'stairway
  <B><FONT COLOR="#5F9EA0">:going</FONT></B>  '(down)
  <B><FONT COLOR="#5F9EA0">:to</FONT></B>     '|Kitchen|
  <B><FONT COLOR="#5F9EA0">:desc</FONT></B>   <B><FONT COLOR="#BC8F8F">&quot;The only exit is a stairway leading down.&quot;</FONT></B>)

(make-container <B><FONT COLOR="#BC8F8F">&quot;mailbox&quot;</FONT></B>
		<B><FONT COLOR="#BC8F8F">&quot;It is rusty, and leans slightly to the left.&quot;</FONT></B>)
(put-in '|West of House| '|mailbox|)

'(setf (immobile-because '|mailbox|) <B><FONT COLOR="#BC8F8F">&quot;It is securely anchored.&quot;</FONT></B>)

(make-object <B><FONT COLOR="#BC8F8F">&quot;leaflet&quot;</FONT></B>
	     <B><FONT COLOR="#BC8F8F">&quot;~%\&quot;WELCOME TO ZORKSim!~%ZORKSim is a game of adventure, danger, and low cunning. In it you will explore some of the most amazing territory ever seen by mortals. No computer should be without one!\&quot;&quot;</FONT></B>)

(put-in '|mailbox| '|leaflet|)

(make-object <B><FONT COLOR="#BC8F8F">&quot;broom&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;It is a roughly-cut shaft of unpolished wood, with a bundle of twigs loosely tied to one end.&quot;</FONT></B>)

(put-in *avatar* '|broom|) 

(make-object-in (location '|mailbox|)
	     <B><FONT COLOR="#BC8F8F">&quot;apple&quot;</FONT></B>
	     <B><FONT COLOR="#BC8F8F">&quot;It is firm and dark red, with a brown stem with a small green leaf coming out of the top.&quot;</FONT></B>)

(setf (is-open (find-obj '|mailbox|)) nil)

(setf *burlap-sack* (make-bag-in *avatar*
	  <B><FONT COLOR="#BC8F8F">&quot;sack&quot;</FONT></B>
	  <B><FONT COLOR="#BC8F8F">&quot;It is made of worn brown burlap and smells slightly of garlic.&quot;</FONT></B>))

<I><FONT COLOR="#B22222">;(setf (immobile-because *burlap-sack*) &quot;As you are about to set it down, you decide that you'd better hold on to it instead.&quot;)
</FONT></I>
(make-object-in *burlap-sack*
	     <B><FONT COLOR="#BC8F8F">&quot;sword&quot;</FONT></B>
	     <B><FONT COLOR="#BC8F8F">&quot;It is made of highly-polished steel, with an ornate wooden handle.&quot;</FONT></B>)

(make-object-in *burlap-sack*
	     <B><FONT COLOR="#BC8F8F">&quot;clove of garlic&quot;</FONT></B>
	     <B><FONT COLOR="#BC8F8F">&quot;You see nothing special about the garlic.&quot;</FONT></B>)

(setf *purse* (make-bag-in *burlap-sack*
	  <B><FONT COLOR="#BC8F8F">&quot;purse&quot;</FONT></B>
	  <B><FONT COLOR="#BC8F8F">&quot;It is small and dirty, with a drawstring around the top.&quot;</FONT></B>))

(make-object-in *purse*
	     <B><FONT COLOR="#BC8F8F">&quot;Euro&quot;</FONT></B>
	     <B><FONT COLOR="#BC8F8F">&quot;The coin is made of tarnished gold and has milled edges.&quot;</FONT></B>)
</PRE>
<HR>
<A NAME="file8">
<H1>lisp/zork/hierarchy.txt 7/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
HasContents
	IsGame
   	IsExaminable
		IsExit
		IsObject
			IsBag
		IsDungeon
		IsRoom
		IsAnimal
			IsPlayer

IsInventoryable
	IsObject
	IsAnimal
	
IsGameComponent
	IsGame
	IsDungeon
	
</PRE>
<HR>
<A NAME="file9">
<H1>lisp/zork/making.lisp 8/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Making
</FONT></I>
(defmacro make-obj-of-class-in (class name location &amp;rest rest)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((obj (gensym)))
    `(<B><FONT COLOR="#A020F0">let</FONT></B> ((,obj (make-instance ,class ,@rest)))
       (<B><FONT COLOR="#A020F0">if</FONT></B> ,name
	   (setf (name ,obj) ,name))
       (<B><FONT COLOR="#A020F0">if</FONT></B> ,location 
	   (setf (location ,obj) ,location))
       ,obj)))

(defmacro make-object-in (location name description &amp;rest rest)
  `(make-obj-of-class-in 'IsPiece
			 ,name
			 ,location
			 <B><FONT COLOR="#5F9EA0">:description</FONT></B> ,description
			 ,@rest))

(defmacro make-object (name description &amp;rest rest)
  `(make-obj-of-class-in 'IsPiece
			 ,name
			 *dungeon*
			 <B><FONT COLOR="#5F9EA0">:description</FONT></B> ,description
			 ,@rest))

(defmacro make-player (name &amp;rest rest)
  `(make-obj-of-class-in 'IsPlayer
			 ,name
			 nil
			 ,@rest))

(defmethod make-bag-in (location name description &amp;optional contents)
  (make-obj-of-class-in 'IsBag
			name
			location
			<B><FONT COLOR="#5F9EA0">:description</FONT></B> description))

(defmethod make-container (name description)
  (make-obj-of-class-in 'IsContainer
			name
			*dungeon*
			<B><FONT COLOR="#5F9EA0">:description</FONT></B> description))

(defmethod make-room (name description)
  (make-obj-of-class-in 'IsRoom
			name
			*dungeon*
			<B><FONT COLOR="#5F9EA0">:description</FONT></B> description))

(defmethod make-dungeon (name description)
  (make-obj-of-class-in 'IsDungeon
			name
			*game*
			<B><FONT COLOR="#5F9EA0">:description</FONT></B> description))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Directions
</FONT></I>
(defmethod make-path (&amp;key dungeon type from going to desc)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((fromR (room-in (<B><FONT COLOR="#A020F0">or</FONT></B> dungeon *dungeon*) from))
	(toR (room-in (<B><FONT COLOR="#A020F0">or</FONT></B> dungeon *dungeon*) to)))
    (make-one-path 
     <B><FONT COLOR="#5F9EA0">:type</FONT></B>  type
     <B><FONT COLOR="#5F9EA0">:from</FONT></B>  fromR
     <B><FONT COLOR="#5F9EA0">:going</FONT></B> going
     <B><FONT COLOR="#5F9EA0">:to</FONT></B>    toR
     <B><FONT COLOR="#5F9EA0">:desc</FONT></B>  desc)))

(defmethod make-paths-from (from paths)
  (make-paths-from (room-in *dungeon* from) paths))

(defmethod make-paths-from ((from IsRoom) paths)
  (dolist (path paths nil)
    (dolist (going (car path) nil)
      (make-one-path
       <B><FONT COLOR="#5F9EA0">:type</FONT></B>  type
       <B><FONT COLOR="#5F9EA0">:from</FONT></B>  from
       <B><FONT COLOR="#5F9EA0">:going</FONT></B> going
       <B><FONT COLOR="#5F9EA0">:to</FONT></B>    (second path)
       <B><FONT COLOR="#5F9EA0">:desc</FONT></B>  (<B><FONT COLOR="#A020F0">or</FONT></B> (third path) <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)))))

(defmethod make-one-path (&amp;key type from going to desc)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((exits (arcs from))
	(new-arc (make-instance 'ExitPath
				<B><FONT COLOR="#5F9EA0">:type</FONT></B> type
				<B><FONT COLOR="#5F9EA0">:to</FONT></B> to
				<B><FONT COLOR="#5F9EA0">:description</FONT></B> desc)))
    (dolist (heading going nil)
      (setf (gethash heading exits) new-arc))))
</PRE>
<HR>
<A NAME="file10">
<H1>lisp/zork/meta.lisp 9/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
(defmacro defreduction (name param-list reduce-name)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((each (gensym)))
    (<B><FONT COLOR="#A020F0">let</FONT></B> ((reduction-funcall (mapcar (<B><FONT COLOR="#A020F0">lambda</FONT></B> (x)
				       (<B><FONT COLOR="#A020F0">if</FONT></B> (atom x)
					   x
					 (<B><FONT COLOR="#A020F0">if</FONT></B> (eql (first x) `,reduce-name)
					     `,each
					   (first x))))
				     `,param-list)))
      (push `,name reduction-funcall)
      <I><FONT COLOR="#B22222">;(prin1 reduction-funcall)
</FONT></I>      `(defmethod ,name ,param-list
	 (dolist (,each ,reduce-name nil)
	   ,reduction-funcall)))))


(set-macro-character #\] (get-macro-character #\)))

'(set-dispatch-macro-character #\# #\[
  #'(<B><FONT COLOR="#A020F0">lambda</FONT></B> (stream char1 char2)
      (<B><FONT COLOR="#A020F0">let</FONT></B>* ((name-list    (read-delimited-list #\] stream t))
	     (name-str-spc (format nil <B><FONT COLOR="#BC8F8F">&quot;~{~A ~}&quot;</FONT></B> name-list))
	     (name-str     (string-right-trim <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> name-str-spc)))
	(multiple-value-list (intern name-str)))))

(set-dispatch-macro-character #\# #\[
  #'(<B><FONT COLOR="#A020F0">lambda</FONT></B> (stream char1 char2)
      (intern 
       (string-right-trim
	<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> 
	(format 
	 nil
	 <B><FONT COLOR="#BC8F8F">&quot;~{~A ~}&quot;</FONT></B> 
	 (read-delimited-list #\] stream t))))))

#|(defmacro defreduction (name param-list reduce-name)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((each (gensym))
	(reduction-funcall (gensym)))
    `(<B><FONT COLOR="#A020F0">let</FONT></B> ((,reduction-funcall (first-ply ',param-list)))
      (push ,name ,reduction-funcall)
      (format t <B><FONT COLOR="#BC8F8F">&quot;reduction-funcall: ~A&quot;</FONT></B> ,reduction-funcall)
      (defmethod ,name ,param-list
		(dolist (,each ,reduce-name nil)
		  ,reduction-funcall)))))
|#

(defmacro first-ply (args)
  `(mapcar #'(<B><FONT COLOR="#A020F0">lambda</FONT></B> (x)
	       (<B><FONT COLOR="#A020F0">if</FONT></B> (atom x)
		   x
		 (first x)))
	   ,args))

(defmacro def-method-alias (old &amp;rest new)
  (dolist (each new nil)
    (setf (symbol-function each) (symbol-function old))))

(def-method-alias exit x)

<I><FONT COLOR="#B22222">;(defun def-method-alias (old newlist &amp;rest rest)
</FONT></I><I><FONT COLOR="#B22222">;  (dolist (each newlist nil)
</FONT></I><I><FONT COLOR="#B22222">;    (setf (symbol-function each) (symbol-function old)))
</FONT></I><I><FONT COLOR="#B22222">;  (if rest
</FONT></I><I><FONT COLOR="#B22222">;      (def-method-alias (car rest) (cadr rest) (cddr rest))))
</FONT></I>
<I><FONT COLOR="#B22222">;(def-method-alias
</FONT></I><I><FONT COLOR="#B22222">;  'exit '(x xit)
</FONT></I><I><FONT COLOR="#B22222">;  'princ '(foo-princ bar-princ))
</FONT></I>
<I><FONT COLOR="#B22222">;;;;
</FONT></I><I><FONT COLOR="#B22222">;;;; Macros from ANSI Common Lisp
</FONT></I><I><FONT COLOR="#B22222">;;;;
</FONT></I>
(defmacro for (var start stop &amp;body body)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((gstop (gensym)))
    `(<B><FONT COLOR="#A020F0">do</FONT></B> ((,var ,start (1+ ,var))
          (,gstop ,stop))
         ((&gt; ,var ,gstop))
       ,@body)))

(defmacro in (obj &amp;rest choices)
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((insym (gensym)))
    `(<B><FONT COLOR="#A020F0">let</FONT></B> ((,insym ,obj))
       (<B><FONT COLOR="#A020F0">or</FONT></B> ,@(mapcar #'(<B><FONT COLOR="#A020F0">lambda</FONT></B> (c) `(eql ,insym ,c))
                     choices)))))

(defmacro random-choice (&amp;rest exprs)
  `(case (random ,(length exprs))
     ,@(<B><FONT COLOR="#A020F0">let</FONT></B> ((key -1))
         (mapcar #'(<B><FONT COLOR="#A020F0">lambda</FONT></B> (expr)
                     `(,(incf key) ,expr))
                 exprs))))

(defmacro avg (&amp;rest args)
  `(/ (+ ,@args) ,(length args)))

#|
(defmacro with-gensyms (syms &amp;body body)
  `(<B><FONT COLOR="#A020F0">let</FONT></B> ,(mapcar #'(<B><FONT COLOR="#A020F0">lambda</FONT></B> (s)
                     `(,s (gensym)))
                 syms)
     ,@body))
|#

(defmacro aif (test then &amp;optional else)
  `(<B><FONT COLOR="#A020F0">let</FONT></B> ((it ,test))
     (<B><FONT COLOR="#A020F0">if</FONT></B> it ,then ,else)))
</PRE>
<HR>
<A NAME="file11">
<H1>lisp/zork/parser.lisp 10/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Tokenization and parsing
</FONT></I>
(defmethod eval-input ((player IsPlayer) input)
  (setf all 'all
	it (it player)
	self player)
  <I><FONT COLOR="#B22222">;(ignore-errors 
</FONT></I>  (eval input))

(defmethod next-command ((player IsPlayer))
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((answer (compile-commands player (prompt-player player))))
    (debug-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;~A~2&amp;&quot;</FONT></B> answer)
    (cons (car answer)
	  (cons player (cdr answer)))))

(defmacro direct-object (list)
  `(car (last ,list)))   <I><FONT COLOR="#B22222">;naive, but works for now
</FONT></I>
(defmethod compile-commands ((player IsPlayer) (input sequence))
  (compile-verbs player input)
  (<B><FONT COLOR="#A020F0">if</FONT></B> (second input)
      (<B><FONT COLOR="#A020F0">let</FONT></B>* ((real-obj (find-for player (direct-object input))))
	(setf (it player) real-obj)
	(<B><FONT COLOR="#A020F0">if</FONT></B> real-obj
	    (<B><FONT COLOR="#A020F0">progn</FONT></B>
	      (debug-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;compiled in object ref to: ~A&quot;</FONT></B> real-obj)
	      (setf (direct-object input) real-obj)
	      input)
	  (<B><FONT COLOR="#A020F0">if</FONT></B> (eql (direct-object input) 'all)
	      input  <I><FONT COLOR="#B22222">;(setf (direct-object input) nil))))
</FONT></I>	    `(nosuch (direct-object ',input)))))
    input))

<I><FONT COLOR="#B22222">;`(or (it ,player)
</FONT></I><I><FONT COLOR="#B22222">;    (nosuch nil))
</FONT></I>
(defmethod compile-verbs ((player IsPlayer) (input sequence))
  (setf (first input) 
	(case (first input)
	  ((open)    'open-container)
	  ((close)   'close-container)
	  (t         (first input)))))

(defmethod prompt-player ((player IsPlayer) &amp;optional (aPrompt (prompt player)))
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;~2&amp;~A &quot;</FONT></B> aPrompt)
  (readlist))

(<B><FONT COLOR="#A020F0">defun</FONT></B> <B><FONT COLOR="#0000FF">readlist</FONT></B> (&amp;rest args)
  (values (read-from-string
	   (concatenate 'string <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B>
			(apply #'read-line args)
			<B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>))))

</PRE>
<HR>
<A NAME="file12">
<H1>lisp/zork/printing.lisp 11/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Looking, examining, describing
</FONT></I>
(defmethod player-format ((player IsPlayer) &amp;rest rest)
  (apply 'format (display player) rest))

(defmethod look ((animal IsAnimal) &amp;optional (thing (location animal)))
  (look-at animal thing))

(def-method-alias look l)

(defmethod look-at <B><FONT COLOR="#5F9EA0">:around</FONT></B> ((player IsPlayer) (object HasLabel))
  (<B><FONT COLOR="#A020F0">if</FONT></B> (can-reach player object)
      (call-next-method player object)
    (player-format <B><FONT COLOR="#BC8F8F">&quot;You can't see ~A here.&quot;</FONT></B> (a-<B><FONT COLOR="#A020F0">or</FONT></B>-an-then object))))

(defmethod look-at ((player IsPlayer) (object HasDescription))
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;~A~&amp;&quot;</FONT></B> (description object)))

(defreduction look-at ((animal IsAnimal) (objs cons)) objs)

(defmethod look-at <B><FONT COLOR="#5F9EA0">:after</FONT></B> ((player IsPlayer) (obj IsBag))
  (<B><FONT COLOR="#A020F0">if</FONT></B>-open obj
	   (print-contents obj (display player))
	   (player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;The ~A is closed.&quot;</FONT></B> obj)))

(defmethod look-at <B><FONT COLOR="#5F9EA0">:after</FONT></B> ((player IsPlayer) (obj IsContainer))
  (<B><FONT COLOR="#A020F0">if</FONT></B>-open obj
	   (print-contents obj (display player))
	   (player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;The ~A is closed.&quot;</FONT></B> obj)))

(defmethod look-at ((player IsPlayer) (room IsRoom))
  (print-object room (display player))
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;~A&quot;</FONT></B> (description room))
  (<B><FONT COLOR="#A020F0">let</FONT></B> ((exits nil))
    (maphash (<B><FONT COLOR="#A020F0">lambda</FONT></B> (key value)
	       (<B><FONT COLOR="#A020F0">unless</FONT></B> (member value exits)
		 (player-format player <B><FONT COLOR="#BC8F8F">&quot; ~A&quot;</FONT></B> (description value))
		 (push value exits)))
	     (arcs room))
    '(print-object-list exits (display player)))
  (dolist (item (contents room) nil)
    (<B><FONT COLOR="#A020F0">unless</FONT></B> (eql item player)
      (player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;There is ~A~A here.~&amp;&quot;</FONT></B> (a-<B><FONT COLOR="#A020F0">or</FONT></B>-an item) item)
      (print-contents item t))))

(defmethod look-at <B><FONT COLOR="#5F9EA0">:before</FONT></B> ((player IsPlayer) (game IsGame))
  (clear-display player))

(defmethod look-at <B><FONT COLOR="#5F9EA0">:after</FONT></B> ((player IsPlayer) (game IsGame))
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;~3&amp;&quot;</FONT></B>))

(defmethod look-at <B><FONT COLOR="#5F9EA0">:after</FONT></B> ((player IsPlayer) (dungeon IsDungeon))
  (player-format player <B><FONT COLOR="#BC8F8F">&quot;~3&amp;&quot;</FONT></B>))

(defmethod inventory ((player IsPlayer))
  (print-contents player (display player)))

(def-method-alias inventory i)

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Printing
</FONT></I>
(defmethod print-object ((thing HasName) str)
  (debug-<B><FONT COLOR="#A020F0">do</FONT></B> thing 
	    (print-attributes thing str)
	    (format str (name thing))))

(defmethod print-contents (item str) nil)

(defmethod print-contents ((item HasContents) str)
  (<B><FONT COLOR="#A020F0">unless</FONT></B> (<B><FONT COLOR="#A020F0">or</FONT></B> (is-empty item)
	      (is-closed item))
    (format str <B><FONT COLOR="#BC8F8F">&quot;~&amp;The ~A contains:~&amp;&quot;</FONT></B> (name item))
    (dolist (each (contents item) nil)
      (format str <B><FONT COLOR="#BC8F8F">&quot;  ~A~A~&amp;&quot;</FONT></B> (capital-a-<B><FONT COLOR="#A020F0">or</FONT></B>-an each) each)
      (print-contents each str))))

(defmethod print-contents ((player IsPlayer) str)
  (<B><FONT COLOR="#A020F0">if</FONT></B> (is-empty player)
      (player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;You are empty-handed.~&amp;&quot;</FONT></B>)
    (<B><FONT COLOR="#A020F0">progn</FONT></B>
      (player-format player <B><FONT COLOR="#BC8F8F">&quot;~&amp;You are carrying:~&amp;&quot;</FONT></B>)
      (dolist (each (contents player) nil)
	(player-format player <B><FONT COLOR="#BC8F8F">&quot;~2T~A~A~&amp;&quot;</FONT></B> (capital-a-<B><FONT COLOR="#A020F0">or</FONT></B>-an each) each)
	(print-contents each str)))))

(defmethod print-object-list ((items cons) str)
    (apply 'format str
	   <B><FONT COLOR="#BC8F8F">&quot;~#[none~;~A~;~A and ~A~:;~@{~#[~;and ~]~A~^, ~}~].&quot;</FONT></B>
	   (mapcar (<B><FONT COLOR="#A020F0">lambda</FONT></B> (each)
		     (a-<B><FONT COLOR="#A020F0">or</FONT></B>-an-then each))
		   items)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- &quot;A &lt;object&gt;&quot; or &quot;An &lt;object&gt;&quot;?
</FONT></I>
(defmethod capital-a-<B><FONT COLOR="#A020F0">or</FONT></B>-an ((obj HasName))
  (capital-a-<B><FONT COLOR="#A020F0">or</FONT></B>-an (name obj)))

(defmethod capital-a-<B><FONT COLOR="#A020F0">or</FONT></B>-an (string)
  (<B><FONT COLOR="#A020F0">if</FONT></B> (begins-with-vowel-sound string)
      <B><FONT COLOR="#BC8F8F">&quot;An &quot;</FONT></B>
    <B><FONT COLOR="#BC8F8F">&quot;A &quot;</FONT></B>))

(defmethod a-<B><FONT COLOR="#A020F0">or</FONT></B>-an ((obj HasName))
  (a-<B><FONT COLOR="#A020F0">or</FONT></B>-an (name obj)))

(defmethod a-<B><FONT COLOR="#A020F0">or</FONT></B>-an-then ((obj HasName))
  (concatenate 'string (a-<B><FONT COLOR="#A020F0">or</FONT></B>-an (name obj)) (name obj)))

(defmethod a-<B><FONT COLOR="#A020F0">or</FONT></B>-an-then ((obj arc))
  (setf desc (description obj))
  (<B><FONT COLOR="#A020F0">if</FONT></B> desc
      (concatenate 'string (a-<B><FONT COLOR="#A020F0">or</FONT></B>-an desc) desc)
    <B><FONT COLOR="#BC8F8F">&quot;an exit&quot;</FONT></B>))

(defmethod a-<B><FONT COLOR="#A020F0">or</FONT></B>-an (string)
  (<B><FONT COLOR="#A020F0">if</FONT></B> (begins-with-vowel-sound string)
      <B><FONT COLOR="#BC8F8F">&quot;an &quot;</FONT></B>
    <B><FONT COLOR="#BC8F8F">&quot;a &quot;</FONT></B>))

(<B><FONT COLOR="#A020F0">defun</FONT></B> <B><FONT COLOR="#0000FF">begins-with-vowel-sound</FONT></B> (str)
  (member (aref str 0) '(#\a #\e #\i #\o #\u #\A #\E #\I #\O #\U)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Printing Attributes
</FONT></I>
(<B><FONT COLOR="#A020F0">defun</FONT></B> <B><FONT COLOR="#0000FF">print-attribute</FONT></B> (attribute obj str)
  (debug-<B><FONT COLOR="#A020F0">do</FONT></B> obj
	(<B><FONT COLOR="#A020F0">progn</FONT></B>
	  (prin1 attribute)
	  (prin1 (funcall attribute obj)))))

(defmethod print-attributes (thing str) nil)

(defmethod print-attributes <B><FONT COLOR="#5F9EA0">:after</FONT></B> ((thing HasLabel) str)
  (prin1 (label thing) str))

(defmethod print-attributes <B><FONT COLOR="#5F9EA0">:after</FONT></B> ((thing HasName) str)
  (prin1 (name thing) str))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- Display
</FONT></I>
(defmethod clear-display ((display (eql t)))
  (format t <B><FONT COLOR="#BC8F8F">&quot;~3&amp;&quot;</FONT></B>))

(defmethod clear-display ((player IsPlayer))
  (clear-display (display player)))

<I><FONT COLOR="#B22222">; ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">; -------------------- 
</FONT></I>
#|
'(defparameter text <B><FONT COLOR="#BC8F8F">&quot;Folding and splicing is the work of an editor, not a mere collection of silicon and mobile electrons!&quot;</FONT></B>)

'(<B><FONT COLOR="#A020F0">defun</FONT></B> <B><FONT COLOR="#0000FF">wrap</FONT></B> (str max-col)
  (<B><FONT COLOR="#A020F0">let</FONT></B>* ((words (string-tokenize str))
         (all nil)
         (first (car words))
         (col (string-length first))
         (line (list first)))
    (mapcar
	(<B><FONT COLOR="#A020F0">lambda</FONT></B> (x)
	  (<B><FONT COLOR="#A020F0">let</FONT></B>* ((len (string-length x))
		 (new-col (+ col len 1)))
	    (<B><FONT COLOR="#A020F0">cond</FONT></B> ((&gt; new-col max-col)
		   (setf all (cons (string-join (reverse! line) <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>) all))
		   (setf line (list x))
		   (setf col len))
		  (else
		   (setf line (cons x line))
		   (setf col new-col)))))
      (cdr words))
    (setf all (cons (string-join (reverse line) <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>) all))
    (string-join (reverse all) <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>)))

'(display (wrap text 20))
|#
</PRE>
<HR>
<A NAME="file13">
<H1>lisp/zork/taxonomy.txt 12/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
chemical
	acidity =
	form in {solid, liquid, gas}
	nutritionalValue = +10%

physical
	sensual
		color in {transparent, translucent, red, green, blue, ....}
		flavor in {}
		odor in
		noise = none
	solubility
	strength
		compressiveStrength
		shearStrength
	subatomic
		conductivity
		magnetism
		radioactivity
	temperature
		current = 75F
		flashPoint = none
		freezingPoint = 0F
		meltingPoint = 275F
	texture = {soft, rough, mottled, ...}
	volume

consumable
	consumptionPerUse

consumer
	animal
	plant
	environment

age
	current
	expectancy

solid is physical
	composition in {wood, metal, plastic, stone, textile, ...}
	dimensions
		l
		w
		h
		volume = l * w * h
		mass
		density
	strength
		tensileStrength
	durability
		wear
		peak

nonsolid
	dispersionRate =
	volume

gaseous is nonsolid
liquid is nonsolid
	consistency = {thick, lumpy, slushy, ...}

ephemeral

container is physical
	upToWeight
	upToSize
	leakageRate = 10%

composition is physical

wood is composition
	type in {balsa, oak, maple, ...}
	flashpoint = 275F

metal is composition
	type in {gold, silver, aluminum, bronze, platinum, iron, steel, magnesium}
	meltingPoint = 300F
	flashpoint = 500F

plastic is composition
	type in {}
	flashpoint = 200F

stone is composition
	type in {marble, granite, basalt, pumice, limestone, slate, shale, coal}
	meltingPoint = 2500F

textile is composition
	type is {reed, grass, cotton, wool, cashmere, flax}
	flashpoint = 200F

cotton
	burnsAt 100F
	leaks liquid at 10% per turn
	leaks gas at 90% per turn

satchel
	is brown, cotton, 1Kg
	smells like garlic
	holds 30Kg, 100cc
	holds NastyKnife, CloveOfGarlic

lamp
	is yellow, plastic, 2Kg
	holds battery
	uses 1Kw/hr
	shatters <B><FONT COLOR="#A020F0">if</FONT></B> thrown
	shatters <B><FONT COLOR="#A020F0">if</FONT></B> droppped at 20%

sword
	is shiny, steel, sharp, 10Kg, 25cc
	is held
	glows within 100m

object
	is descriptor
	attracts/seeks/wants &lt;obj&gt;
	repels/avoids &lt;obj&gt;
	has &lt;obj&gt;
	consumes &lt;obj&gt; at rate
	can &lt;ability&gt;
	interacts with &lt;obj&gt;</PRE>
<HR>
<A NAME="file14">
<H1>lisp/zork/transcript.zork1 13/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
ZORK I: The Great Underground Empire
Copyright (c) 1981, 1982, 1983 Infocom, Inc. All rights reserved.
ZORK is a registered trademark of Infocom, Inc
Revision 88 / Serial number 840726

West of House
You are standing in an open field west of a white house, with a boarded front
door.
There is a small mailbox here.

&gt;open mailbox
Opening the small mailbox reveals a leaflet.

&gt;read leaflet
(Taken)
<B><FONT COLOR="#BC8F8F">&quot;WELCOME TO ZORK!

ZORK is a game of adventure, danger, and low cunning. In it you will explore
some of the most amazing territory ever seen by mortals. No computer should be
without one!&quot;</FONT></B>

&gt;n
North of House
You are facing the north side of a white house. There is no door here, <B><FONT COLOR="#A020F0">and</FONT></B> all
the windows are boarded up. To the north a narrow path winds through the trees.

&gt;s
The windows are all boarded.

&gt;e
Behind House
You are behind the white house. A path leads into the forest to the east. In one
corner of the house there is a small window which is slightly ajar.

&gt;open windoew
I don't know the word <B><FONT COLOR="#BC8F8F">&quot;windoew&quot;</FONT></B>.

&gt;open window
With great effort, you open the window far enough to allow entry.

&gt;in
Kitchen
You are in the kitchen of the white house. A table seems to have been used
recently for the preparation of food. A passage leads to the west <B><FONT COLOR="#A020F0">and</FONT></B> a dark
staircase can be seen leading upward. A dark chimney leads down <B><FONT COLOR="#A020F0">and</FONT></B> to the east
is a small window which is open.
On the table is an elongated brown sack, smelling of hot peppers.
A bottle is sitting on the table.
The glass bottle contains:
  A quantity of water

&gt;take sack
Taken.

&gt;look in sack
The brown sack is closed.

&gt;open sack
Opening the brown sack reveals a lunch, <B><FONT COLOR="#A020F0">and</FONT></B> a clove of garlic.

&gt;up
You have moved into a dark place.
It is pitch black. You are likely to be eaten by a grue.

&gt;d
Kitchen
A bottle is sitting on the table.
The glass bottle contains:
  A quantity of water

&gt;w
Living Room
You are in the living room. There is a doorway to the east, a wooden door with
strange gothic lettering to the west, which appears to be nailed shut, a trophy
case, <B><FONT COLOR="#A020F0">and</FONT></B> a large oriental rug in the center of the room.
Above the trophy case hangs an elvish sword of great antiquity.
A battery-powered brass lantern is on the trophy case.

&gt;take lamp
Taken.

&gt;look at lamp
The lamp is turned off.

&gt;look at sword
There's nothing special about the sword.

&gt;look at lettin
I don't know the word <B><FONT COLOR="#BC8F8F">&quot;lettin&quot;</FONT></B>.

&gt;look at lettering
The engravings translate to <B><FONT COLOR="#BC8F8F">&quot;This space intentionally left blank.&quot;</FONT></B>

&gt;
&gt;move
What <B><FONT COLOR="#A020F0">do</FONT></B> you want to move?

&gt;take
(sword)
Taken.

&gt;take
What <B><FONT COLOR="#A020F0">do</FONT></B> you want to take?

&gt;rug
The rug is extremely heavy <B><FONT COLOR="#A020F0">and</FONT></B> cannot be carried.

&gt;move rug
With a great effort, the rug is moved to one side of the room, revealing the
dusty cover of a closed trap door.

&gt;open door
Which door <B><FONT COLOR="#A020F0">do</FONT></B> you mean, the wooden door <B><FONT COLOR="#A020F0">or</FONT></B> the trap door?

&gt;trap
The door reluctantly opens to reveal a rickety staircase descending into
darkness.

&gt;score
Your score is 10 (total of 350 points), in 19 moves.
This gives you the rank of Beginner.

&gt;e
Kitchen
A bottle is sitting on the table.
The glass bottle contains:
  A quantity of water

&gt;u
You have moved into a dark place.
It is pitch black. You are likely to be eaten by a grue.

&gt;turn on lamp
The brass lantern is now on.

Attic
This is the attic. The only exit is a stairway leading down.
A large coil of rope is lying in the corner.
On a table is a nasty-looking knife.

&gt;&gt;w
Living Room

&gt;d
The trap door crashes shut, <B><FONT COLOR="#A020F0">and</FONT></B> you hear someone barring it.

Cellar
You are in a dark <B><FONT COLOR="#A020F0">and</FONT></B> damp cellar with a narrow passageway leading north, <B><FONT COLOR="#A020F0">and</FONT></B> a
crawlway to the south. On the west is the bottom of a steep metal ramp which is
unclimbable.
Your sword is glowing with a faint blue glow.

&gt;s
East of Chasm
You are on the east edge of a chasm, the bottom of which cannot be seen. A
narrow passage goes north, <B><FONT COLOR="#A020F0">and</FONT></B> the path you are on continues to the east.
Your sword is no longer glowing.

&gt;e
Gallery
This is an art gallery. Most of the paintings have been stolen by vandals with
exceptional taste. The vandals left through either the north <B><FONT COLOR="#A020F0">or</FONT></B> west exits.
Fortunately, there is still one chance for you to be a vandal, for on the far
wall is a painting of unparalleled beauty.

&gt;n
Studio
This appears to have been an artist's studio. The walls <B><FONT COLOR="#A020F0">and</FONT></B> floors are
splattered with paints of 69 different colors. Strangely enough, nothing of
value is hanging here. At the south end of the room is an open door (also
covered with paint). A dark <B><FONT COLOR="#A020F0">and</FONT></B> narrow chimney leads up from a fireplace<I><FONT COLOR="#B22222">;
</FONT></I>although you might be able to get up it, it seems unlikely you could get back
down.
Loosely attached to a wall is a small piece of paper.

&gt;take paper
Taken.

&gt;read paper

Congratulations!

You are the privileged owner of ZORK I: The Great Underground Empire, a self-
contained <B><FONT COLOR="#A020F0">and</FONT></B> self-maintaining universe. If used <B><FONT COLOR="#A020F0">and</FONT></B> maintained in accordance
with normal operating practices for small universes, ZORK will provide many
months of trouble-free operation.

</PRE>
<HR>
<A NAME="file15">
<H1>lisp/zork/zorksim.lisp 14/14</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
(load <B><FONT COLOR="#BC8F8F">&quot;meta.lisp&quot;</FONT></B>)
(load <B><FONT COLOR="#BC8F8F">&quot;classes.lisp&quot;</FONT></B>)
(load <B><FONT COLOR="#BC8F8F">&quot;printing.lisp&quot;</FONT></B>)
(load <B><FONT COLOR="#BC8F8F">&quot;parser.lisp&quot;</FONT></B>)
(load <B><FONT COLOR="#BC8F8F">&quot;all.lisp&quot;</FONT></B>)
(load <B><FONT COLOR="#BC8F8F">&quot;making.lisp&quot;</FONT></B>)

<I><FONT COLOR="#B22222">; --------------------- Make game and player
</FONT></I>
(defparameter *avatar* (make-player <B><FONT COLOR="#BC8F8F">&quot;Avatar&quot;</FONT></B>))

(<B><FONT COLOR="#A020F0">defun</FONT></B> <B><FONT COLOR="#0000FF">this-room</FONT></B> ()
  (location *avatar*))

(defparameter *game* (make-instance 
   'IsGame
   <B><FONT COLOR="#5F9EA0">:label</FONT></B> '|ZorkSim|
   <B><FONT COLOR="#5F9EA0">:max-score</FONT></B> 200
   <B><FONT COLOR="#5F9EA0">:description</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;Welcome to ZorkSim, the land of adventure and low cunning.&quot;</FONT></B>))

(def-method-alias toggle-debug-mode g)

'(<B><FONT COLOR="#A020F0">defun</FONT></B> <B><FONT COLOR="#0000FF">toggle-debug</FONT></B> ()
  (toggle-debug-mode *avatar*))

<I><FONT COLOR="#B22222">; -------------------- Make dungeon and rooms
</FONT></I>
(defparameter *dungeon* 
  (make-dungeon
   <B><FONT COLOR="#BC8F8F">&quot;Zork 1&quot;</FONT></B>
   <B><FONT COLOR="#BC8F8F">&quot;You awaken, unsure whether your dream has ended...&quot;</FONT></B>))

(load <B><FONT COLOR="#BC8F8F">&quot;dungeon1.lisp&quot;</FONT></B>)
(setf (entrance *game*) *dungeon*)

<I><FONT COLOR="#B22222">; -------------------- Begin the game!
</FONT></I>
(enter *avatar* *game*)
</PRE>
<HR/><ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>
</HTML>
