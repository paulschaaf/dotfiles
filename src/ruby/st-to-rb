#!/usr/bin/ruby

indent='  '

# make normal linefeeds
`recode mac..latin1 StreamParser.rb`

ARGV.each {|file|
  lastClass=nil

  contents = File.open(file, 'r').read.instance_eval {

    gsub!("\r","\n")

    # remove ! marks
    delete!('!')

    # remove trailing whitespace
    gsub!('[ \t]+$', '')

    # convert tabs to spaces
    gsub!("\t", indent)

    # indent every line once more
    gsub!('^', indent)
    gsub!('^ *=(begin|end)', '=\1')

    gsub!("^=begin\\s*'", "=begin\n")
    gsub!("\\s*'\\s*=end", "\n=end")

    # convert chars
    #gsub!('\$', '%')
    #gsub!('Character cr', '$/')

    # convert symbols
    gsub!('#', ':')

    # convert statement terminators
    gsub!('\.$', '')

    # change category headers to class extensions
    gsub!("^ *(.*) methodsFor: '(.*)'$") {|match|
      answer = 
	(if $1 == lastClass
	   ''
	else
	   lastClass = $1
	   "end\n\nclass #{$1}\n"
	end)
      answer + "#{indent}##----------\n#{indent}## #{$2}"
    }

    # put class declaration on single line
    gsub!(/\n[ \t]*(instanceVariableNames|classVariableNames|poolDictionaries|category)/m, ' \1')

    # transform class declarations
    gsub!(" *(.*) subclass: :(.*) instanceVariableNames: '(.*), ' classVariableNames: '(.*)' poolDictionaries: '(.*)' category: '(.*)'") {|match|
      this_super, this_class, ivars, cvars, pools, category = $~[1..6]
#$1, $2, $3, $4, $5, $6
      answer = ["\nend\n"]
      answer << "# Category: #{category}" unless category.empty?
      answer << "class #{this_class} < #{this_super}"
      answer << "#{indent}# PoolDictionaries: #{pools}" unless pools.empty?
      answer << "#{indent}# ClassVariables: #{cvars}" unless cvars.empty?
      answer << "#{indent}attr_accessor #{ivars}" unless ivars.empty?
      answer.join($/)
    }

    # clean up method definitions
    gsub!('(^\s*def [^:]*): (.*)', '\1(\2)')

    # clean up message sends
    gsub!('(self) ([^:]*): (.*)', '\1.\2(\3)')

    # convert comments
    gsub!(/\"([^\"]*)\"/m) {|match| 
      "# #{$1.split($/).join($/ + indent + indent + '#')}"}
    gsub!("# #{indent}*", '# ')

    # convert fileout metainfo
    gsub!(" *'(From VisualWorks[^']*)'", '# \1')
    gsub!(" *#\\\\(.*)", '# \1')

    # convert blocks
    gsub!(/\[\s*:([^|]*)\|/m) {|match|
      "[|#{$1.strip.split(' :').join(', ')}|"
    }
    gsub!('\[', '{')
    gsub!('\]', '}')

    # convert common messages
    gsub!(' keysAndValuesDo:', '.each_pair')
    gsub!(' do:', '.each')
    gsub!(' asString', '.to_s')
    gsub!('Character cr', '$/')

    gsub!('self ', 'self.')
    gsub!('super ', 'super.')

    class_mappings = {
      :Dictionary => Hash,
      :IdentityDictionary => Hash,
      :OrderedCollection => Array,
      :Bag => Array,
      :Set => Array,
      :ObjectMemory => :ObjectSpace
    }

    class_mappings.each_pair {|key, value|
      puts "alias :#{key} :#{value}"
    }
    puts

    puts 'begin', self, 'end'
  }

}
